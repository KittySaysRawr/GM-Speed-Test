<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Speed Checker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css">
    <style>
        :root {
            --green-primary: #4CAF50;
            --green-dark: #2E7D32;
            --green-light: #C8E6C9;
            --amber: #FF9800;
            --red: #F44336;
            --text-dark: #333;
            --text-light: #fff;
            --bg-light: #f5f5f5;
            --bg-dark: #263238;
            --blue: #2196F3;
            --purple: #9C27B0;
            --teal: #009688;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg-light);
            color: var(--text-dark);
            transition: all 0.3s ease;
            min-height: 100vh;
        }
        
        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-light);
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .dark-mode .container {
            background: #37474F;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
        }
        
        .location-info {
            background: var(--green-light);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-size: 0.95em;
        }
        
        .dark-mode .location-info {
            background: #1B5E20;
        }
        
        .location-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        
        .location-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            min-width: 300px;
            justify-content: space-between;
        }
        
        .dark-mode .location-row {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .location-text {
            font-weight: 500;
            flex-grow: 1;
            text-align: left;
        }
        
        .flag-icon {
            width: 24px;
            height: 18px;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .server-map {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .server-pill {
            background: #e0e0e0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .server-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.2);
        }
        
        .server-pill.testing {
            background: var(--green-primary);
            color: white;
            transform: scale(1.05);
        }
        
        .server-pill.selected {
            background: var(--green-dark);
            color: white;
            font-weight: bold;
            border: 2px solid var(--green-primary);
        }
        
        .server-pill.failed {
            background: #ffebee;
            color: #c62828;
        }
        
        .dark-mode .server-pill {
            background: #455A64;
        }
        
        .dark-mode .server-pill.testing {
            background: var(--green-primary);
        }
        
        .dark-mode .server-pill.selected {
            background: var(--green-dark);
        }
        
        .speed-result {
            display: none;
            text-align: center;
            padding: 40px 30px;
            margin: 20px 0;
            border-radius: 8px;
            background: var(--green-light);
            animation: fadeIn 0.8s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .dark-mode .speed-result {
            background: #1B5E20;
        }
        
        .speed-value {
            font-size: 3.5em;
            font-weight: bold;
            margin: 10px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .speed-value {
            color: var(--text-light);
        }
        
        .speed-good { color: var(--green-dark); }
        .speed-medium { color: var(--amber); }
        .speed-slow { color: var(--red); }
        .speed-excellent { color: var(--blue); }
        .speed-ultra { color: var(--purple); }
        
        .test-button {
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            transition: all 0.3s ease;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        
        .test-button:hover:not(:disabled) {
            transform: translateY(-3px);
            background: var(--green-dark);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        .test-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }
        
        .test-details {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .detail-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 10px;
            min-width: 150px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dark-mode .detail-box {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .detail-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .detail-value {
            color: var(--text-light);
        }
        
        .detail-label {
            font-size: 0.95em;
            color: #666;
            font-weight: 500;
        }
        
        .dark-mode .detail-label {
            color: #ccc;
        }
        
        .progress-container {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            margin: 40px 0 30px 0;
            overflow: hidden;
            display: none;
        }
        
        .dark-mode .progress-container {
            background: #455A64;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--green-primary), var(--green-dark));
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .status-message {
            text-align: center;
            margin: 25px 0;
            font-size: 1.1em;
            color: #666;
            min-height: 28px;
            font-weight: 500;
        }
        
        .dark-mode .status-message {
            color: #ccc;
        }
        
        .test-stages {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            font-size: 0.95em;
            color: #666;
        }
        
        .dark-mode .test-stages {
            color: #ddd;
        }
        
        .test-stage {
            text-align: center;
            flex: 1;
            padding: 10px 5px;
            opacity: 0.5;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .test-stage.active {
            color: var(--green-primary);
            font-weight: bold;
            opacity: 1;
            border-bottom: 3px solid var(--green-primary);
        }
        
        .dark-mode .test-stage.active {
            color: var(--green-primary);
        }
        
        .connection-info {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9em;
            color: #666;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
        }
        
        .dark-mode .connection-info {
            background: rgba(0, 0, 0, 0.2);
            color: #ccc;
        }
        
        .jitter-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .accuracy-note {
            text-align: center;
            font-size: 0.85em;
            color: #888;
            margin-top: 20px;
            font-style: italic;
        }
        
        .dark-mode .accuracy-note {
            color: #aaa;
        }
        
        .connection-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .badge-wifi { background: #4CAF50; color: white; }
        .badge-4g { background: #2196F3; color: white; }
        .badge-5g { background: #9C27B0; color: white; }
        .badge-ethernet { background: #795548; color: white; }
        .badge-unknown { background: #9E9E9E; color: white; }
        
        /* Result status text */
        .result-status {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 30px;
            padding: 8px 20px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .result-status-excellent {
            background-color: rgba(46, 125, 50, 0.15);
            color: var(--green-dark);
            border: 2px solid rgba(46, 125, 50, 0.3);
        }
        
        .dark-mode .result-status-excellent {
            background-color: rgba(76, 175, 80, 0.2);
            color: #C8E6C9;
            border: 2px solid rgba(76, 175, 80, 0.4);
        }
        
        .result-status-good {
            background-color: rgba(255, 152, 0, 0.15);
            color: #EF6C00;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }
        
        .dark-mode .result-status-good {
            background-color: rgba(255, 152, 0, 0.2);
            color: #FFE0B2;
            border: 2px solid rgba(255, 152, 0, 0.4);
        }
        
        .result-status-slow {
            background-color: rgba(244, 67, 54, 0.15);
            color: #D32F2F;
            border: 2px solid rgba(244, 67, 54, 0.3);
        }
        
        .dark-mode .result-status-slow {
            background-color: rgba(244, 67, 54, 0.2);
            color: #FFCDD2;
            border: 2px solid rgba(244, 67, 54, 0.4);
        }
        
        /* IMPROVED Preloader with colorful spinner */
        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-light);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .dark-mode .preloader {
            background: var(--bg-dark);
        }
        
        .preloader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .preloader-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .loading-text {
            font-size: 1.4em;
            color: var(--text-dark);
            font-weight: 500;
            margin-bottom: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            text-align: center;
        }
        
        .dark-mode .loading-text {
            color: var(--text-light);
        }
        
        .spinner-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        /* Colorful spinner with gradient effect */
        .spinner {
            width: 120px;
            height: 120px;
            border: 10px solid transparent;
            border-top: 10px solid var(--green-primary);
            border-right: 10px solid var(--blue);
            border-bottom: 10px solid var(--purple);
            border-left: 10px solid var(--teal);
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
            position: relative;
            box-sizing: border-box;
        }
        
        /* Inner circle that fits perfectly inside the spinner border */
        .spinner-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        
        .dark-mode .spinner-inner {
            background: #37474F;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        /* Percentage perfectly centered inside inner circle */
        .spinner-percentage {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--green-dark);
            line-height: 1;
            text-align: center;
        }
        
        .dark-mode .spinner-percentage {
            color: var(--green-light);
        }
        
        @keyframes spin {
            0% { 
                transform: rotate(0deg); 
                border-top-color: var(--green-primary);
                border-right-color: var(--blue);
                border-bottom-color: var(--purple);
                border-left-color: var(--teal);
            }
            25% {
                border-top-color: var(--blue);
                border-right-color: var(--purple);
                border-bottom-color: var(--teal);
                border-left-color: var(--green-primary);
            }
            50% {
                border-top-color: var(--purple);
                border-right-color: var(--teal);
                border-bottom-color: var(--green-primary);
                border-left-color: var(--blue);
            }
            75% {
                border-top-color: var(--teal);
                border-right-color: var(--green-primary);
                border-bottom-color: var(--blue);
                border-left-color: var(--purple);
            }
            100% { 
                transform: rotate(360deg);
                border-top-color: var(--green-primary);
                border-right-color: var(--blue);
                border-bottom-color: var(--purple);
                border-left-color: var(--teal);
            }
        }
        
        /* Connection type indicator */
        .connection-type-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
            font-size: 0.85em;
            color: #666;
        }
        
        .dark-mode .connection-type-indicator {
            color: #ccc;
        }
        
        /* Server selection section */
        .server-selection {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            display: none;
        }
        
        .dark-mode .server-selection {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .server-selection h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-dark);
        }
        
        .dark-mode .server-selection h3 {
            color: var(--text-light);
        }
        
        .server-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .server-option {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            min-width: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            max-width: 250px;
        }
        
        .server-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-color: var(--green-primary);
        }
        
        .server-option.selected {
            border-color: var(--green-primary);
            background: var(--green-light);
            transform: translateY(-3px);
        }
        
        .dark-mode .server-option {
            background: #37474F;
            border-color: #455A64;
        }
        
        .dark-mode .server-option.selected {
            background: #1B5E20;
            border-color: var(--green-primary);
        }
        
        .server-option-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        
        .server-option-ping {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
            min-height: 20px;
        }
        
        .dark-mode .server-option-ping {
            color: #ccc;
        }
        
        .server-option-location {
            font-size: 0.85em;
            color: #888;
        }
        
        .dark-mode .server-option-location {
            color: #aaa;
        }
        
        .server-flag {
            width: 24px;
            height: 18px;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .ping-testing {
            font-size: 0.8em;
            color: #FF9800;
            font-style: italic;
        }
        
        .ping-success {
            color: #4CAF50;
        }
        
        .ping-high {
            color: #F44336;
        }
        
        /* Permission prompts */
        .permission-request {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .permission-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .dark-mode .permission-content {
            background: #37474F;
            color: var(--text-light);
        }
        
        .permission-content h3 {
            margin-top: 0;
            color: var(--green-dark);
        }
        
        .dark-mode .permission-content h3 {
            color: var(--green-light);
        }
        
        .permission-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .permission-btn {
            padding: 12px 24px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .permission-btn.allow {
            background: var(--green-primary);
            color: white;
        }
        
        .permission-btn.allow:hover {
            background: var(--green-dark);
        }
        
        .permission-btn.deny {
            background: #e0e0e0;
            color: #333;
        }
        
        .permission-btn.deny:hover {
            background: #cccccc;
        }
        
        .dark-mode .permission-btn.deny {
            background: #455A64;
            color: var(--text-light);
        }
        
        .dark-mode .permission-btn.deny:hover {
            background: #546E7A;
        }
    </style>
</head>
<body>
    <div class="preloader" id="preloader">
        <div class="preloader-content">
            <div class="loading-text" id="loadingText">Taking the fish for a walk...</div>
            <div class="spinner-container">
                <div class="spinner"></div>
                <div class="spinner-inner">
                    <div class="spinner-percentage" id="loadingPercentage">0%</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Location Permission Request -->
    <div class="permission-request" id="locationPermissionRequest">
        <div class="permission-content">
            <h3>Location Access Required</h3>
            <p>For accurate speed testing, we need to know your location to find the nearest test servers.</p>
            <p>This allows us to show you servers with the lowest ping times for the most accurate results.</p>
            <div class="permission-buttons">
                <button class="permission-btn allow" onclick="allowLocationPermission()">Allow Location Access</button>
                <button class="permission-btn deny" onclick="denyLocationPermission()">Continue Without Location</button>
            </div>
        </div>
    </div>
    
    <!-- Connection Information Request -->
    <div class="permission-request" id="connectionPermissionRequest">
        <div class="permission-content">
            <h3>Network Information Access</h3>
            <p>To accurately detect your connection type (WiFi, 4G, 5G, etc.), we need access to your network information.</p>
            <p>This helps provide more accurate speed analysis and connection type detection.</p>
            <div class="permission-buttons">
                <button class="permission-btn allow" onclick="allowConnectionInfo()">Allow Network Info</button>
                <button class="permission-btn deny" onclick="continueWithoutConnectionInfo()">Continue Without</button>
            </div>
        </div>
    </div>
    
    <button class="theme-toggle" onclick="toggleTheme()">Toggle Light/Dark</button>
    
    <div class="container">
        <div class="header">
            <h1>Internet Speed Checker</h1>
            <p>Test your internet connection speed</p>
        </div>
        
        <div class="location-info" id="locationInfo">
            <div class="location-display">
                <div class="location-row">
                    <span class="location-text" id="userLocation">Detecting your location...</span>
                    <span class="flag-icon" id="userFlag"></span>
                </div>
                <div class="location-row">
                    <span class="location-text" id="testServer">Select a test server below</span>
                    <span class="flag-icon" id="serverFlag"></span>
                </div>
            </div>
        </div>
        
        <div class="server-selection" id="serverSelection">
            <h3>Select a Test Server</h3>
            <p>Servers are tested for ping during page load. Choose the server with the lowest ping:</p>
            <div class="server-options" id="serverOptions">
                <!-- Server options will be added here dynamically -->
            </div>
        </div>
        
        <div class="server-map" id="serverMap" style="display: none;">
            <!-- Server pills will be added here dynamically -->
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="test-stages" id="testStages">
            <div class="test-stage" id="stageLocation">Finding Nearest Server</div>
            <div class="test-stage" id="stagePing">Latency Test</div>
            <div class="test-stage" id="stageDownload">Download Test</div>
            <div class="test-stage" id="stageUpload">Upload Test</div>
            <div class="test-stage" id="stageComplete">Analysis</div>
        </div>
        
        <div class="status-message" id="statusMessage">
            Testing nearby servers for ping...
        </div>
        
        <button class="test-button" onclick="startSpeedTest()" id="testButton" disabled>Testing Servers...</button>
        
        <div id="speedResult" class="speed-result">
            <h2>Connection Analysis Results</h2>
            <div id="speedValue" class="speed-value">--</div>
            <div id="speedStatus" class="result-status">--</div>
            
            <div class="test-details">
                <div class="detail-box">
                    <div class="detail-value" id="downloadSpeed">--</div>
                    <div class="detail-label">DOWNLOAD SPEED</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="downloadQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="uploadSpeed">--</div>
                    <div class="detail-label">UPLOAD SPEED</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="uploadQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="pingValue">--</div>
                    <div class="detail-label">PING</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="pingQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="jitterValue">--</div>
                    <div class="detail-label">JITTER</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="jitterQuality">--</div>
                </div>
            </div>
            
            <div class="connection-info">
                <div id="ispInfo"><strong>ISP:</strong> --</div>
                <div id="connectionType" style="margin-top: 8px;"><strong>Connection Type:</strong> --</div>
                <div id="networkType" style="margin-top: 8px;"><strong>Network Technology:</strong> --</div>
                <div id="detectedLocation" style="margin-top: 8px;"><strong>Your Location:</strong> --</div>
                <div id="connectionAccuracy" style="margin-top: 8px; font-size: 0.85em; color: #666;">
                    <strong>Detection Confidence:</strong> Speed-based analysis combined with browser API
                </div>
            </div>
            
            <div class="accuracy-note">
                Network type detected based on speed, latency, and browser capabilities
            </div>
        </div>
    </div>

    <script>
        // Theme toggle
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }
        
        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
        
        // Fun animal-themed loading messages
        const loadingMessages = [
            "Taking the fish for a walk...",
            "Teaching pigs to fly...",
            "Giving cats swimming lessons...",
            "Training dogs to use chopsticks...",
            "Teaching squirrels to tap dance...",
            "Organizing a turtle marathon...",
            "Giving rabbits a driving test...",
            "Teaching birds to write poetry...",
            "Training mice to play chess...",
            "Giving elephants ballet lessons...",
            "Teaching cows to use smartphones...",
            "Training ants to build skyscrapers...",
            "Giving penguins sunbathing lessons...",
            "Teaching sloths to sprint...",
            "Training monkeys to do taxes...",
            "Giving zebras a fashion makeover...",
            "Teaching giraffes limbo dancing...",
            "Training koalas to stay awake...",
            "Giving octopuses knitting lessons...",
            "Ready to test your connection!"
        ];
        
        // Location cache
        const LOCATION_CACHE_KEY = 'speedtest_location_cache';
        const LOCATION_CACHE_TTL = 30 * 60 * 1000;
        
        let testInProgress = false;
        let userLocation = null;
        let bestServer = null;
        let detectedConnectionType = 'Unknown';
        let detectedNetworkTech = 'Unknown';
        let loadingProgress = 0;
        let serverCandidates = [];
        let pingTestResults = new Map();
        let serverTestingInProgress = false;
        let locationPermissionGranted = false;
        let connectionInfoPermissionGranted = false;
        
        // Country code to flag mapping
        const countryFlagMap = {
            'GB': 'gb', 'UK': 'gb', 'US': 'us', 'DE': 'de', 'JP': 'jp',
            'FR': 'fr', 'CA': 'ca', 'AU': 'au', 'BR': 'br', 'IN': 'in',
            'CN': 'cn', 'RU': 'ru', 'IT': 'it', 'ES': 'es', 'NL': 'nl',
            'SE': 'se', 'NO': 'no', 'DK': 'dk', 'FI': 'fi', 'PL': 'pl',
            'IE': 'ie', 'CH': 'ch', 'BE': 'be', 'AT': 'at', 'PT': 'pt',
            'SG': 'sg', 'HK': 'hk', 'KR': 'kr', 'TW': 'tw', 'MX': 'mx'
        };
        
        // Get flag class for country code
        function getFlagClass(countryCode) {
            const code = (countryCode || 'unknown').toUpperCase();
            if (countryFlagMap[code]) {
                return `flag-icon-${countryFlagMap[code]}`;
            }
            return 'flag-icon-us'; // Default to US flag
        }
        
        // EXPANDED Server database with global distribution
        const testServers = [
            // North America
            { 
                id: 'cdn_na', 
                name: "San Francisco, USA", 
                pingUrl: "https://1.1.1.1/cdn-cgi/trace",
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=20000000",
                uploadUrl: "https://httpbin.org/post",
                country: "United States",
                countryCode: "US",
                city: "San Francisco",
                lat: 37.7749,
                lon: -122.4194,
                region: "na",
                description: "Cloudflare North America"
            },
            { 
                id: 'github_na', 
                name: "California, USA", 
                pingUrl: "https://raw.githubusercontent.com/git/git/master/README.md",
                downloadUrl: "https://raw.githubusercontent.com/torvalds/linux/master/README",
                uploadUrl: "https://httpbin.org/post",
                country: "United States",
                countryCode: "US",
                city: "California",
                lat: 37.7749,
                lon: -122.4194,
                region: "na",
                description: "GitHub USA Server"
            },
            { 
                id: 'cdn_ny', 
                name: "New York, USA", 
                pingUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "United States",
                countryCode: "US",
                city: "New York",
                lat: 40.7128,
                lon: -74.0060,
                region: "na",
                description: "Cloudflare East Coast"
            },
            // Europe
            { 
                id: 'cdn_eu', 
                name: "Amsterdam, Netherlands", 
                pingUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                downloadUrl: "https://eu.speed.cloudflare.com/__down?bytes=20000000",
                uploadUrl: "https://httpbin.org/post",
                country: "Netherlands",
                countryCode: "NL",
                city: "Amsterdam",
                lat: 52.3676,
                lon: 4.9041,
                region: "eu",
                description: "Cloudflare Europe"
            },
            { 
                id: 'jsdelivr_eu', 
                name: "Frankfurt, Germany", 
                pingUrl: "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js",
                downloadUrl: "https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Germany",
                countryCode: "DE",
                city: "Frankfurt",
                lat: 50.1109,
                lon: 8.6821,
                region: "eu",
                description: "jsDelivr Europe"
            },
            // UK specific
            { 
                id: 'cdn_uk', 
                name: "London, UK", 
                pingUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "United Kingdom",
                countryCode: "GB",
                city: "London",
                lat: 51.5074,
                lon: -0.1278,
                region: "eu",
                description: "Cloudflare UK"
            },
            { 
                id: 'github_uk', 
                name: "London, UK", 
                pingUrl: "https://raw.githubusercontent.com/torvalds/linux/master/README",
                downloadUrl: "https://raw.githubusercontent.com/torvalds/linux/master/README",
                uploadUrl: "https://httpbin.org/post",
                country: "United Kingdom",
                countryCode: "GB",
                city: "London",
                lat: 51.5074,
                lon: -0.1278,
                region: "eu",
                description: "GitHub Europe"
            },
            // Asia
            { 
                id: 'cdn_asia', 
                name: "Singapore", 
                pingUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Singapore",
                countryCode: "SG",
                city: "Singapore",
                lat: 1.3521,
                lon: 103.8198,
                region: "asia",
                description: "Cloudflare Asia"
            },
            { 
                id: 'cdn_jp', 
                name: "Tokyo, Japan", 
                pingUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Japan",
                countryCode: "JP",
                city: "Tokyo",
                lat: 35.6762,
                lon: 139.6503,
                region: "asia",
                description: "Cloudflare Japan"
            },
            // Australia
            { 
                id: 'cdn_au', 
                name: "Sydney, Australia", 
                pingUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Australia",
                countryCode: "AU",
                city: "Sydney",
                lat: -33.8688,
                lon: 151.2093,
                region: "au",
                description: "Cloudflare Australia"
            },
            // Global fallbacks
            { 
                id: 'cdn_global', 
                name: "Global Network", 
                pingUrl: "https://1.1.1.1/cdn-cgi/trace",
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=10000000",
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                countryCode: "GL",
                city: "Anycast Network",
                lat: null,
                lon: null,
                region: "global",
                description: "Global anycast network"
            }
        ];
        
        // Update loading progress with whimsical messages
        function updateLoadingProgress(progress) {
            loadingProgress = Math.min(100, Math.max(0, progress));
            const percentageEl = document.getElementById('loadingPercentage');
            const loadingTextEl = document.getElementById('loadingText');
            
            percentageEl.textContent = `${Math.round(loadingProgress)}%`;
            
            // Update loading message based on progress
            const messageIndex = Math.min(
                Math.floor(loadingProgress / 5),
                loadingMessages.length - 1
            );
            loadingTextEl.textContent = loadingMessages[messageIndex];
            
            const spinner = document.querySelector('.spinner');
            if (loadingProgress < 30) {
                spinner.style.borderTopColor = '#FF9800';
                spinner.style.borderRightColor = '#2196F3';
                spinner.style.borderBottomColor = '#9C27B0';
                spinner.style.borderLeftColor = '#009688';
            } else if (loadingProgress < 70) {
                spinner.style.borderTopColor = '#4CAF50';
                spinner.style.borderRightColor = '#FF9800';
                spinner.style.borderBottomColor = '#2196F3';
                spinner.style.borderLeftColor = '#9C27B0';
            } else {
                spinner.style.borderTopColor = '#009688';
                spinner.style.borderRightColor = '#4CAF50';
                spinner.style.borderBottomColor = '#FF9800';
                spinner.style.borderLeftColor = '#2196F3';
            }
        }
        
        // Haversine formula for distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            if (!lat1 || !lon1 || !lat2 || !lon2) return Infinity;
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Get cached location
        function getCachedLocation() {
            try {
                const cached = localStorage.getItem(LOCATION_CACHE_KEY);
                if (!cached) return null;
                
                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();
                
                if (now - timestamp < LOCATION_CACHE_TTL) {
                    return data;
                }
                
                localStorage.removeItem(LOCATION_CACHE_KEY);
                return null;
            } catch (error) {
                return null;
            }
        }
        
        // Cache location data
        function cacheLocationData(locationData) {
            try {
                const cacheData = {
                    data: locationData,
                    timestamp: Date.now()
                };
                localStorage.setItem(LOCATION_CACHE_KEY, JSON.stringify(cacheData));
            } catch (error) {
                // Ignore caching errors
            }
        }
        
        // Permission handling functions
        function allowLocationPermission() {
            document.getElementById('locationPermissionRequest').style.display = 'none';
            locationPermissionGranted = true;
            initializeApp();
        }
        
        function denyLocationPermission() {
            document.getElementById('locationPermissionRequest').style.display = 'none';
            locationPermissionGranted = false;
            initializeApp();
        }
        
        function allowConnectionInfo() {
            document.getElementById('connectionPermissionRequest').style.display = 'none';
            connectionInfoPermissionGranted = true;
            initializeApp();
        }
        
        function continueWithoutConnectionInfo() {
            document.getElementById('connectionPermissionRequest').style.display = 'none';
            connectionInfoPermissionGranted = false;
            initializeApp();
        }
        
        // Check for required permissions
        function checkPermissions() {
            const hasGeolocation = 'geolocation' in navigator;
            const hasConnectionAPI = 'connection' in navigator;
            
            // Show location permission request if needed
            if (hasGeolocation && !locationPermissionGranted) {
                document.getElementById('locationPermissionRequest').style.display = 'flex';
                return false;
            }
            
            // Show connection info permission request if needed
            if (hasConnectionAPI && !connectionInfoPermissionGranted) {
                document.getElementById('connectionPermissionRequest').style.display = 'flex';
                return false;
            }
            
            return true;
        }
        
        // IMPROVED: Try to get precise location from browser GPS
        async function getPreciseLocation() {
            if (!locationPermissionGranted) return null;
            
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            source: 'gps'
                        });
                    },
                    (error) => {
                        // User denied or error getting GPS location
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        // IMPROVED: More accurate location detection
        async function detectUserLocation() {
            updateLoadingProgress(40);
            
            // Check cache first
            const cached = getCachedLocation();
            if (cached) {
                updateLoadingProgress(50);
                await new Promise(resolve => setTimeout(resolve, 300));
                return cached;
            }
            
            let locationData = {
                country: 'Unknown',
                city: 'Unknown',
                region: 'Unknown',
                latitude: null,
                longitude: null,
                isp: 'Unknown',
                method: 'unknown',
                countryCode: 'Unknown',
                accuracy: 'low',
                continent: 'Unknown'
            };
            
            // Try multiple location sources in order of accuracy
            
            // 1. First try browser GPS for most accurate location
            try {
                updateLoadingProgress(45);
                const preciseLocation = await getPreciseLocation();
                if (preciseLocation) {
                    locationData.latitude = preciseLocation.latitude;
                    locationData.longitude = preciseLocation.longitude;
                    locationData.accuracy = 'high';
                    locationData.method = 'gps';
                    
                    // Try to reverse geocode GPS coordinates for city/country
                    try {
                        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${preciseLocation.latitude}&lon=${preciseLocation.longitude}&zoom=10`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.address) {
                                locationData.city = data.address.city || data.address.town || data.address.village || data.address.municipality || 'Unknown';
                                locationData.country = data.address.country || 'Unknown';
                                locationData.countryCode = data.address.country_code?.toUpperCase() || 'Unknown';
                                locationData.region = data.address.state || data.address.region || 'Unknown';
                            }
                        }
                    } catch (error) {
                        // Continue with IP-based location
                    }
                }
            } catch (error) {
                // GPS failed, continue with IP-based detection
            }
            
            // 2. If no GPS or couldn't reverse geocode, try IP-based location
            if (!locationData.city || locationData.city === 'Unknown') {
                try {
                    updateLoadingProgress(55);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    
                    // Try ipapi.co first
                    const response = await fetch('https://ipapi.co/json/', {
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        updateLoadingProgress(65);
                        const data = await response.json();
                        
                        // Only update if we don't have better data
                        if (!locationData.city || locationData.city === 'Unknown') {
                            locationData.city = data.city || 'Unknown';
                        }
                        if (!locationData.country || locationData.country === 'Unknown') {
                            locationData.country = data.country_name || 'Unknown';
                        }
                        if (!locationData.countryCode || locationData.countryCode === 'Unknown') {
                            locationData.countryCode = data.country_code || 'Unknown';
                        }
                        if (!locationData.region || locationData.region === 'Unknown') {
                            locationData.region = data.region || 'Unknown';
                        }
                        if (!locationData.latitude) {
                            locationData.latitude = data.latitude;
                        }
                        if (!locationData.longitude) {
                            locationData.longitude = data.longitude;
                        }
                        locationData.isp = data.org || data.asn || 'Unknown ISP';
                        locationData.method = locationData.method === 'gps' ? 'gps+ip' : 'ip_geolocation';
                        
                        // Determine continent from country code
                        if (data.country_code) {
                            const continent = getContinentFromCountryCode(data.country_code);
                            locationData.continent = continent;
                        }
                    }
                } catch (error) {
                    // Try alternative IP service
                    try {
                        const backupResponse = await fetch('https://ipinfo.io/json?token=free', {
                            signal: AbortSignal.timeout(3000)
                        });
                        
                        if (backupResponse.ok) {
                            const data = await backupResponse.json();
                            const [lat, lon] = data.loc ? data.loc.split(',').map(Number) : [null, null];
                            
                            if (!locationData.city || locationData.city === 'Unknown') {
                                locationData.city = data.city || 'Unknown';
                            }
                            if (!locationData.country || locationData.country === 'Unknown') {
                                locationData.country = data.country || 'Unknown';
                            }
                            if (!locationData.countryCode || locationData.countryCode === 'Unknown') {
                                locationData.countryCode = data.country || 'Unknown';
                            }
                            if (!locationData.region || locationData.region === 'Unknown') {
                                locationData.region = data.region || 'Unknown';
                            }
                            if (!locationData.latitude) {
                                locationData.latitude = lat;
                            }
                            if (!locationData.longitude) {
                                locationData.longitude = lon;
                            }
                            locationData.isp = data.org || data.hostname || 'Unknown ISP';
                            locationData.method = locationData.method === 'gps' ? 'gps+ip' : 'ipinfo_io';
                            
                            // Determine continent from country code
                            if (data.country) {
                                const continent = getContinentFromCountryCode(data.country);
                                locationData.continent = continent;
                            }
                        }
                    } catch (backupError) {
                        // Fallback to browser detection
                        updateLoadingProgress(60);
                        const browserLanguage = navigator.language || 'en-US';
                        const countryCode = browserLanguage.split('-')[1] || 'US';
                        locationData.countryCode = countryCode;
                        locationData.method = 'browser_language';
                        locationData.continent = getContinentFromCountryCode(countryCode);
                    }
                }
            }
            
            // 3. Final fallback if still no location
            if (locationData.city === 'Unknown' && locationData.country === 'Unknown') {
                locationData.country = 'Detected from browser';
                locationData.method = 'browser_detection';
                locationData.continent = 'Unknown';
            }
            
            updateLoadingProgress(70);
            cacheLocationData(locationData);
            
            return locationData;
        }
        
        // Helper function to determine continent from country code
        function getContinentFromCountryCode(countryCode) {
            const code = countryCode.toUpperCase();
            
            // Europe
            const europeCodes = ['GB', 'UK', 'DE', 'FR', 'IT', 'ES', 'NL', 'SE', 'NO', 'DK', 'FI', 'PL', 'IE', 'CH', 'BE', 'AT', 'PT', 'GR', 'CZ', 'HU', 'RO', 'BG'];
            if (europeCodes.includes(code)) return 'eu';
            
            // North America
            const naCodes = ['US', 'CA', 'MX'];
            if (naCodes.includes(code)) return 'na';
            
            // South America
            const saCodes = ['BR', 'AR', 'CL', 'CO', 'PE'];
            if (saCodes.includes(code)) return 'sa';
            
            // Asia
            const asiaCodes = ['CN', 'JP', 'IN', 'RU', 'KR', 'SG', 'TH', 'VN', 'MY', 'ID', 'PH', 'HK', 'TW'];
            if (asiaCodes.includes(code)) return 'asia';
            
            // Australia/Oceania
            const auCodes = ['AU', 'NZ'];
            if (auCodes.includes(code)) return 'au';
            
            // Africa
            const africaCodes = ['ZA', 'NG', 'EG', 'KE'];
            if (africaCodes.includes(code)) return 'africa';
            
            return 'global';
        }
        
        // Test server ping with detailed progress
        async function testServerPing(server) {
            let pings = [];
            
            for (let i = 0; i < 3; i++) {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    await fetch(server.pingUrl + `?pingtest=${Date.now()}-${i}`, {
                        signal: controller.signal,
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const ping = endTime - startTime;
                    
                    if (ping > 1 && ping < 2000) {
                        pings.push(ping);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                } catch (error) {
                    pings.push(300); // High penalty for failed ping
                }
            }
            
            if (pings.length === 0) return 300;
            
            // Return the median ping
            pings.sort((a, b) => a - b);
            return pings[Math.floor(pings.length / 2)];
        }
        
        // Test multiple servers for ping in parallel with limited concurrency
        async function testMultipleServers(servers, concurrency = 3) {
            const results = [];
            const queue = [...servers];
            
            // Process servers with limited concurrency
            const workers = Array(concurrency).fill().map(async () => {
                while (queue.length > 0) {
                    const server = queue.shift();
                    if (!server) continue;
                    
                    try {
                        const ping = await testServerPing(server);
                        results.push({
                            server: server,
                            ping: ping
                        });
                        
                        // Update UI with progress
                        updateServerPingProgress(server, ping);
                        
                    } catch (error) {
                        results.push({
                            server: server,
                            ping: 300 // Default high ping for failed tests
                        });
                    }
                }
            });
            
            await Promise.all(workers);
            return results;
        }
        
        // Update UI with ping test progress
        function updateServerPingProgress(server, ping) {
            const serverOptions = document.getElementById('serverOptions');
            const serverElements = serverOptions.getElementsByClassName('server-option');
            
            for (let element of serverElements) {
                const title = element.querySelector('.server-option-title');
                if (title && title.textContent.includes(server.name)) {
                    const pingElement = element.querySelector('.server-option-ping');
                    if (pingElement) {
                        if (ping < 300) {
                            pingElement.innerHTML = `Ping: <span class="${ping < 100 ? 'ping-success' : ping < 200 ? '' : 'ping-high'}">${Math.round(ping)}ms</span>`;
                        } else {
                            pingElement.innerHTML = `Ping: <span class="ping-high">Failed</span>`;
                        }
                    }
                    break;
                }
            }
        }
        
        // Find closest servers based on geographical distance
        function findClosestServers(userLocation, count = 6) {
            if (!userLocation || (!userLocation.latitude && !userLocation.longitude)) {
                // If no location, return random servers from different regions
                return getDiverseServers(count);
            }
            
            const serversWithDistance = testServers
                .filter(server => server.lat && server.lon)
                .map(server => {
                    const distance = calculateDistance(
                        userLocation.latitude,
                        userLocation.longitude,
                        server.lat,
                        server.lon
                    );
                    return { server, distance };
                })
                .sort((a, b) => a.distance - b.distance);
            
            // Get closest servers
            const closest = serversWithDistance.slice(0, Math.min(count, serversWithDistance.length));
            
            // If we don't have enough servers with coordinates, add some without coordinates
            if (closest.length < count) {
                const serversWithoutCoords = testServers
                    .filter(server => !server.lat || !server.lon)
                    .slice(0, count - closest.length);
                closest.push(...serversWithoutCoords.map(server => ({ server, distance: Infinity })));
            }
            
            return closest.map(item => item.server);
        }
        
        // Get servers from different regions for global coverage
        function getDiverseServers(count) {
            const regions = ['na', 'eu', 'asia', 'au', 'global'];
            const result = [];
            
            for (const region of regions) {
                const regionServers = testServers.filter(s => s.region === region);
                if (regionServers.length > 0) {
                    result.push(regionServers[0]);
                    if (result.length >= count) break;
                }
            }
            
            // Fill remaining slots with any servers
            if (result.length < count) {
                const remaining = testServers
                    .filter(s => !result.includes(s))
                    .slice(0, count - result.length);
                result.push(...remaining);
            }
            
            return result;
        }
        
        // Find and display best server options with ping testing
        async function findAndTestServerOptions(userLocation) {
            updateLoadingProgress(75);
            const statusMessage = document.getElementById('statusMessage');
            const testButton = document.getElementById('testButton');
            
            statusMessage.textContent = 'Finding closest servers...';
            
            // Find closest servers based on location
            const closestServers = findClosestServers(userLocation, 6);
            
            // Create initial server options with "Testing..." placeholder
            createServerOptions(closestServers);
            
            // Start ping testing
            statusMessage.textContent = 'Testing server ping times...';
            testButton.disabled = true;
            testButton.textContent = 'Testing Servers...';
            
            // Test all servers for ping
            const pingResults = await testMultipleServers(closestServers, 3);
            
            // Store results
            pingTestResults.clear();
            pingResults.forEach(result => {
                pingTestResults.set(result.server.id, result.ping);
            });
            
            // Sort servers by ping
            const sortedResults = pingResults.sort((a, b) => a.ping - b.ping);
            
            // Update server options with actual ping results
            updateServerOptionsWithResults(sortedResults);
            
            // Set best server (lowest ping)
            if (sortedResults.length > 0) {
                bestServer = sortedResults[0].server;
                updateServerDisplay(bestServer);
                
                // Enable test button
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                statusMessage.textContent = 'Select a server or click Start Test';
            } else {
                statusMessage.textContent = 'No servers available. Please try again.';
            }
            
            return sortedResults.map(result => ({
                server: result.server,
                ping: result.ping,
                score: calculateServerScore(Infinity, result.ping, userLocation.continent, result.server.region)
            }));
        }
        
        // Create initial server options
        function createServerOptions(servers) {
            const serverSelection = document.getElementById('serverSelection');
            const serverOptions = document.getElementById('serverOptions');
            
            // Clear existing options
            serverOptions.innerHTML = '';
            
            // Create options for each server
            servers.forEach((server, index) => {
                const option = document.createElement('div');
                option.className = 'server-option';
                option.dataset.serverId = server.id;
                
                // Create flag element
                const flagClass = getFlagClass(server.countryCode);
                
                option.innerHTML = `
                    <div class="server-option-title">
                        <span class="server-flag ${flagClass}"></span>
                        ${server.name}
                    </div>
                    <div class="server-option-ping">Ping: <span class="ping-testing">Testing...</span></div>
                    <div class="server-option-location">${server.description}</div>
                `;
                
                option.addEventListener('click', () => {
                    if (pingTestResults.has(server.id)) {
                        // Remove selected class from all options
                        document.querySelectorAll('.server-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        
                        // Add selected class to clicked option
                        option.classList.add('selected');
                        
                        // Update selected server
                        bestServer = server;
                        updateServerDisplay(server);
                        
                        // Update status message
                        const ping = pingTestResults.get(server.id);
                        const statusMessage = document.getElementById('statusMessage');
                        statusMessage.textContent = `Selected ${server.city} (${Math.round(ping)}ms ping)`;
                    }
                });
                
                serverOptions.appendChild(option);
            });
            
            // Show server selection section
            serverSelection.style.display = 'block';
        }
        
        // Update server options with ping results
        function updateServerOptionsWithResults(results) {
            const serverOptions = document.getElementById('serverOptions');
            
            // Sort results by ping
            results.sort((a, b) => a.ping - b.ping);
            
            // Update each server option
            results.forEach((result, index) => {
                const serverElement = serverOptions.querySelector(`[data-server-id="${result.server.id}"]`);
                if (serverElement) {
                    const pingElement = serverElement.querySelector('.server-option-ping');
                    if (pingElement) {
                        if (result.ping < 300) {
                            pingElement.innerHTML = `Ping: <span class="${result.ping < 100 ? 'ping-success' : result.ping < 200 ? '' : 'ping-high'}">${Math.round(result.ping)}ms</span>`;
                        } else {
                            pingElement.innerHTML = `Ping: <span class="ping-high">Failed</span>`;
                        }
                    }
                    
                    // Select the server with the lowest ping by default
                    if (index === 0) {
                        serverElement.classList.add('selected');
                    }
                }
            });
        }
        
        // Display server options for user selection
        function displayServerOptions(candidates) {
            const serverSelection = document.getElementById('serverSelection');
            const testButton = document.getElementById('testButton');
            const statusMessage = document.getElementById('statusMessage');
            
            // Show server selection section
            serverSelection.style.display = 'block';
            
            // Enable test button if we have candidates
            if (candidates.length > 0) {
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                statusMessage.textContent = 'Select a server or click Start Test';
            }
        }
        
        // Update server display with selected server
        function updateServerDisplay(server) {
            const testServerEl = document.getElementById('testServer');
            const serverFlagEl = document.getElementById('serverFlag');
            
            let serverText = 'Test Server: ';
            if (server.country === 'Global') {
                serverText += 'Global CDN Network';
            } else {
                serverText += `${server.city}, ${server.country}`;
            }
            testServerEl.textContent = serverText;
            
            // Update server flag
            if (server.countryCode && server.countryCode !== 'GL') {
                serverFlagEl.className = `flag-icon ${getFlagClass(server.countryCode)}`;
                serverFlagEl.style.display = 'inline-block';
            } else {
                serverFlagEl.className = 'flag-icon flag-icon-globe';
                serverFlagEl.style.display = 'inline-block';
            }
        }
        
        // Calculate server score based on distance, ping, and region match
        function calculateServerScore(distance, ping, userContinent, serverRegion) {
            let score = 100;
            
            // Base score on ping (lower ping = higher score)
            if (ping < 50) score += 50;
            else if (ping < 100) score += 30;
            else if (ping < 200) score += 10;
            else if (ping < 300) score += 5;
            else score -= 20;
            
            // Bonus for regional match
            if (userContinent === serverRegion) {
                score += 40;
            } else if (serverRegion === 'global') {
                score += 10;
            }
            
            // Bonus for short distance (if known)
            if (distance < 1000 && distance !== Infinity) {
                score += 30;
            } else if (distance < 3000 && distance !== Infinity) {
                score += 15;
            } else if (distance < 5000 && distance !== Infinity) {
                score += 5;
            }
            
            // Penalty for very high ping
            if (ping > 500) {
                score -= 50;
            }
            
            return score;
        }
        
        // Update location display with flags
        function updateLocationDisplay(location) {
            const userLocationEl = document.getElementById('userLocation');
            const userFlagEl = document.getElementById('userFlag');
            
            // Update user location with more specific info
            let locationText = 'Your Location: ';
            if (location.city !== 'Unknown' && location.region !== 'Unknown' && location.country !== 'Unknown') {
                locationText += `${location.city}, ${location.region}, ${location.country}`;
            } else if (location.city !== 'Unknown' && location.country !== 'Unknown') {
                locationText += `${location.city}, ${location.country}`;
            } else if (location.country !== 'Unknown') {
                locationText += location.country;
            } else {
                locationText += 'Location detected from connection data';
            }
            userLocationEl.textContent = locationText;
            
            // Update user flag
            if (location.countryCode && location.countryCode !== 'Unknown') {
                userFlagEl.className = `flag-icon ${getFlagClass(location.countryCode)}`;
                userFlagEl.style.display = 'inline-block';
            } else {
                userFlagEl.style.display = 'none';
            }
        }
        
        // IMPROVED: Better 5G detection WITHOUT 2G/3G
        async function detectConnectionType(downloadSpeed, uploadSpeed, ping, jitter) {
            let connectionInfo = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            // First check browser API (modern networks only)
            if (connectionInfoPermissionGranted) {
                const browserDetection = detectConnectionFromBrowser();
                if (browserDetection.type !== 'Unknown') {
                    connectionInfo = browserDetection;
                    connectionInfo.details.push('Detected via browser API');
                    connectionInfo.confidence = 70;
                }
            }
            
            // Then analyze speed patterns with modern networks only
            const speedDetection = detectConnectionFromSpeed(downloadSpeed, uploadSpeed, ping, jitter);
            
            // IMPORTANT: If speed detection suggests 5G, prioritize it over browser detection
            // Browser often mislabels 5G as 4G
            if (speedDetection.technology === '5G') {
                connectionInfo = speedDetection;
                connectionInfo.details.push('Speed analysis indicates 5G (browser may mislabel as 4G)');
                connectionInfo.confidence = Math.max(connectionInfo.confidence, 85);
            } else if (speedDetection.confidence > connectionInfo.confidence || connectionInfo.type === 'Unknown') {
                connectionInfo = speedDetection;
                connectionInfo.details.push('Detected via speed analysis');
            }
            
            // Special 5G detection for high speeds
            if (downloadSpeed > 200 && ping < 30 && jitter < 15) {
                // Ultra-fast speeds with low latency = very likely 5G
                connectionInfo.technology = '5G';
                connectionInfo.type = 'Mobile';
                connectionInfo.confidence = 95;
                connectionInfo.details.push('Ultra-high speed with low latency indicates 5G');
            } else if (downloadSpeed > 100 && uploadSpeed > 20 && ping < 40 && jitter < 20) {
                // High speeds with good upload = likely 5G
                connectionInfo.technology = '5G';
                connectionInfo.type = 'Mobile';
                connectionInfo.confidence = 85;
                connectionInfo.details.push('High symmetrical speeds indicate 5G');
            }
            
            // Clean up connection type display
            if (connectionInfo.technology === '5G' || connectionInfo.technology === '4G/LTE') {
                connectionInfo.type = 'Mobile';
            } else if (connectionInfo.technology === 'WiFi') {
                connectionInfo.type = 'WiFi';
            } else if (connectionInfo.technology === 'Fiber' || connectionInfo.technology === 'Cable' || connectionInfo.technology === 'DSL') {
                connectionInfo.type = 'Wired';
            } else if (connectionInfo.technology === 'Satellite') {
                connectionInfo.type = 'Satellite';
            }
            
            return connectionInfo;
        }
        
        function detectConnectionFromBrowser() {
            const info = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            if (!('connection' in navigator)) {
                info.details.push('No browser connection API available');
                return info;
            }
            
            const conn = navigator.connection;
            
            if (conn.type) {
                info.type = conn.type;
                info.confidence = 60;
                info.details.push(`Browser reports type: ${conn.type}`);
            }
            
            if (conn.effectiveType) {
                // Browser may report 5G as "4g" - we'll override this later based on speed
                info.technology = conn.effectiveType.toUpperCase();
                info.confidence = Math.max(info.confidence, 50);
                info.details.push(`Browser reports effective type: ${conn.effectiveType}`);
                
                // Map to our technology names (modern networks only)
                if (conn.effectiveType.includes('4g')) {
                    info.technology = '4G/LTE';
                }
                // Note: 2G and 3G are deprecated and removed
            }
            
            if (conn.downlink) {
                info.details.push(`Estimated downlink: ${conn.downlink} Mbps`);
            }
            
            if (conn.type === 'cellular' || conn.effectiveType) {
                info.type = 'Mobile';
            }
            
            if (conn.type === 'wifi' || conn.type === 'wimax') {
                info.type = 'WiFi';
                info.technology = 'WiFi';
            }
            
            if (conn.type === 'ethernet') {
                info.type = 'Wired';
                info.technology = 'Ethernet';
            }
            
            return info;
        }
        
        function detectConnectionFromSpeed(downloadSpeed, uploadSpeed, ping, jitter) {
            const info = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            let bestMatch = null;
            let bestScore = 0;
            
            // MODERN NETWORK TYPES ONLY - No 2G or 3G
            const networkTypePatterns = {
                '5G': {
                    minDownload: 100,
                    maxDownload: 3000,
                    minUpload: 10,
                    maxUpload: 200,
                    maxPing: 40,
                    maxJitter: 15,
                    scoreMultiplier: 1.2
                },
                '4G/LTE': {
                    minDownload: 10,
                    maxDownload: 150,
                    minUpload: 2,
                    maxUpload: 50,
                    maxPing: 80,
                    maxJitter: 25,
                    scoreMultiplier: 1.0
                },
                'Fiber': {
                    minDownload: 50,
                    maxDownload: 5000,
                    minUpload: 50,
                    maxUpload: 5000,
                    maxPing: 30,
                    maxJitter: 10,
                    scoreMultiplier: 1.1
                },
                'Cable': {
                    minDownload: 25,
                    maxDownload: 1000,
                    minUpload: 5,
                    maxUpload: 100,
                    maxPing: 40,
                    maxJitter: 15,
                    scoreMultiplier: 1.0
                },
                'DSL': {
                    minDownload: 5,
                    maxDownload: 100,
                    minUpload: 1,
                    maxUpload: 20,
                    maxPing: 60,
                    maxJitter: 25,
                    scoreMultiplier: 1.0
                },
                'WiFi': {
                    minDownload: 10,
                    maxDownload: 500,
                    minUpload: 5,
                    maxUpload: 100,
                    maxPing: 50,
                    maxJitter: 30,
                    scoreMultiplier: 1.0
                },
                'Satellite': {
                    minDownload: 5,
                    maxDownload: 100,
                    minUpload: 1,
                    maxUpload: 20,
                    minPing: 500,
                    maxPing: 2000,
                    maxJitter: 100,
                    scoreMultiplier: 1.0
                }
            };
            
            for (const [tech, pattern] of Object.entries(networkTypePatterns)) {
                let score = 0;
                
                // Download speed match
                if (downloadSpeed >= pattern.minDownload && downloadSpeed <= pattern.maxDownload) {
                    score += 30;
                } else if (downloadSpeed > pattern.maxDownload && tech !== '5G') {
                    // Very high speeds suggest 5G or Fiber
                    score += 15;
                } else if (downloadSpeed < pattern.minDownload) {
                    score += 5;
                }
                
                // Upload speed match
                if (uploadSpeed >= pattern.minUpload && uploadSpeed <= pattern.maxUpload) {
                    score += 20;
                }
                
                // Ping/latency match
                if (tech === 'Satellite') {
                    if (ping >= pattern.minPing && ping <= pattern.maxPing) {
                        score += 40;
                    }
                } else if (ping <= pattern.maxPing) {
                    score += 25;
                }
                
                // Jitter match
                if (jitter <= pattern.maxJitter) {
                    score += 15;
                }
                
                // Special characteristics
                if (tech === 'Fiber') {
                    const ratio = uploadSpeed / downloadSpeed;
                    if (ratio > 0.3 && ratio < 3) {
                        score += 25;
                    }
                }
                
                if (tech === '5G' && downloadSpeed > 200 && ping < 30) {
                    score += 30;
                }
                
                // Apply multiplier
                score *= pattern.scoreMultiplier;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = tech;
                }
            }
            
            if (bestMatch && bestScore > 40) {
                info.technology = bestMatch;
                info.confidence = Math.min(95, bestScore);
                info.details.push(`Matched ${bestMatch} pattern with score ${Math.round(bestScore)}`);
                
                // Map technology to type
                if (bestMatch === '5G' || bestMatch === '4G/LTE') {
                    info.type = 'Mobile';
                } else if (bestMatch === 'WiFi') {
                    info.type = 'WiFi';
                } else if (bestMatch === 'Fiber' || bestMatch === 'Cable' || bestMatch === 'DSL') {
                    info.type = 'Wired';
                } else if (bestMatch === 'Satellite') {
                    info.type = 'Satellite';
                }
            }
            
            return info;
        }
        
        // Test download speed
        async function testDownloadSpeed() {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Testing download speed...';
            
            let speeds = [];
            const testDuration = 4000;
            const parallelConnections = 4;
            
            const downloadServers = [
                { url: "https://speed.cloudflare.com/__down?bytes=20000000", size: 20000000 },
                { url: "https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js", size: 89513 },
                { url: "https://raw.githubusercontent.com/torvalds/linux/master/README", size: 37000 },
            ];
            
            for (const server of downloadServers) {
                try {
                    const speed = await measureDownloadSpeed(server.url, server.size, testDuration, parallelConnections);
                    
                    if (speed > 0.1 && speed < 10000) {
                        speeds.push(speed);
                    }
                    
                    if (speeds.length >= 2) break;
                    
                } catch (error) {
                    continue;
                }
            }
            
            if (speeds.length === 0) {
                return await simpleDownloadTest();
            }
            
            const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            return Math.round(averageSpeed * 10) / 10;
        }
        
        async function measureDownloadSpeed(url, fileSize, duration, connections) {
            const startTime = performance.now();
            let totalBytes = 0;
            
            return new Promise((resolve, reject) => {
                const connectionPromises = [];
                
                for (let i = 0; i < connections; i++) {
                    connectionPromises.push(
                        fetch(url + `?nocache=${Date.now()}-${i}`, {
                            cache: 'no-store',
                            headers: {
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            }
                        }).then(async response => {
                            const reader = response.body.getReader();
                            let bytesReceived = 0;
                            
                            while (performance.now() - startTime < duration) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                bytesReceived += value.length;
                                totalBytes += value.length;
                            }
                            
                            reader.cancel();
                            return bytesReceived;
                        }).catch(error => {
                            return 0;
                        })
                    );
                }
                
                const progressInterval = setInterval(() => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed >= duration) {
                        clearInterval(progressInterval);
                        const speedMbps = (totalBytes * 8) / (duration / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                    }
                }, 100);
                
                setTimeout(() => {
                    clearInterval(progressInterval);
                    const elapsed = performance.now() - startTime;
                    const speedMbps = (totalBytes * 8) / (elapsed / 1000) / (1024 * 1024);
                    resolve(speedMbps);
                }, duration + 1000);
            });
        }
        
        async function simpleDownloadTest() {
            try {
                const startTime = performance.now();
                const response = await fetch('https://speed.cloudflare.com/__down?bytes=10000000' + `?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                const blob = await response.blob();
                const endTime = performance.now();
                
                const duration = (endTime - startTime) / 1000;
                const speedMbps = (blob.size * 8) / (1024 * 1024) / duration;
                
                return Math.max(0.1, speedMbps);
            } catch (error) {
                return 10;
            }
        }
        
        // IMPROVED: Better upload speed test with larger data and multiple connections
        async function testUploadSpeed() {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Testing upload speed...';
            
            let speeds = [];
            const testDuration = 5000; // Increased duration for better accuracy
            
            // Try multiple upload endpoints with different data sizes
            const uploadTests = [
                { endpoint: 'https://httpbin.org/post', dataSize: 5 * 1024 * 1024 }, // 5MB
                { endpoint: 'https://httpbin.org/post', dataSize: 10 * 1024 * 1024 }, // 10MB
            ];
            
            for (const test of uploadTests) {
                try {
                    const speed = await measureUploadSpeedAdvanced(test.endpoint, test.dataSize, testDuration);
                    
                    if (speed > 0.1 && speed < 5000) {
                        speeds.push(speed);
                    }
                    
                    if (speeds.length >= 2) break;
                    
                } catch (error) {
                    continue;
                }
            }
            
            if (speeds.length === 0) {
                // Fallback to simpler test
                return await simpleUploadTest();
            }
            
            // Take the highest speed measurement
            const maxSpeed = Math.max(...speeds);
            return Math.round(maxSpeed * 10) / 10;
        }
        
        function generateTestData(size) {
            // Use ArrayBuffer for more efficient data generation
            const buffer = new ArrayBuffer(size);
            const view = new Uint8Array(buffer);
            
            // Fill with random data
            for (let i = 0; i < size; i++) {
                view[i] = Math.floor(Math.random() * 256);
            }
            
            return buffer;
        }
        
        // IMPROVED: Advanced upload speed measurement with multiple connections
        async function measureUploadSpeedAdvanced(endpoint, dataSize, duration) {
            const startTime = performance.now();
            let totalBytesSent = 0;
            const connections = 3; // Use multiple connections for better throughput
            const chunkSize = 256 * 1024; // 256KB chunks
            
            return new Promise((resolve, reject) => {
                const connectionPromises = [];
                
                for (let i = 0; i < connections; i++) {
                    connectionPromises.push(
                        new Promise(async (resolveConn) => {
                            let bytesSent = 0;
                            const testData = generateTestData(Math.min(dataSize, 2 * 1024 * 1024)); // Max 2MB per connection
                            
                            const sendChunk = async () => {
                                if (performance.now() - startTime >= duration || bytesSent >= dataSize) {
                                    resolveConn(bytesSent);
                                    return;
                                }
                                
                                try {
                                    const chunkSizeToSend = Math.min(chunkSize, testData.byteLength - bytesSent);
                                    const chunk = testData.slice(bytesSent, bytesSent + chunkSizeToSend);
                                    
                                    const controller = new AbortController();
                                    const timeoutId = setTimeout(() => controller.abort(), 8000);
                                    
                                    const response = await fetch(endpoint, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/octet-stream',
                                            'Content-Length': chunkSizeToSend.toString()
                                        },
                                        body: chunk,
                                        signal: controller.signal
                                    });
                                    
                                    clearTimeout(timeoutId);
                                    
                                    if (response.ok) {
                                        bytesSent += chunkSizeToSend;
                                        totalBytesSent += chunkSizeToSend;
                                        setTimeout(sendChunk, 0);
                                    } else {
                                        resolveConn(bytesSent);
                                    }
                                } catch (error) {
                                    resolveConn(bytesSent);
                                }
                            };
                            
                            sendChunk();
                        })
                    );
                }
                
                // Monitor progress and calculate speed
                const progressInterval = setInterval(() => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed >= duration) {
                        clearInterval(progressInterval);
                        
                        // Wait for all connections to finish
                        Promise.all(connectionPromises).then(() => {
                            const finalElapsed = performance.now() - startTime;
                            const speedMbps = (totalBytesSent * 8) / (finalElapsed / 1000) / (1024 * 1024);
                            resolve(speedMbps);
                        });
                    }
                }, 100);
                
                // Safety timeout
                setTimeout(() => {
                    clearInterval(progressInterval);
                    const elapsed = performance.now() - startTime;
                    const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                    resolve(speedMbps);
                }, duration + 8000);
            });
        }
        
        // Simple fallback upload test
        async function simpleUploadTest() {
            try {
                const testData = generateTestData(2 * 1024 * 1024); // 2MB
                
                const startTime = performance.now();
                const response = await fetch('https://httpbin.org/post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/octet-stream',
                    },
                    body: testData
                });
                
                await response.json();
                const endTime = performance.now();
                
                const duration = (endTime - startTime) / 1000;
                const speedMbps = (testData.byteLength * 8) / (1024 * 1024) / duration;
                
                return Math.max(0.1, speedMbps);
                
            } catch (error) {
                return 2;
            }
        }
        
        async function performLatencyTest() {
            let pings = [];
            let jitterSamples = [];
            
            statusMessage.textContent = 'Measuring latency and jitter...';
            
            for (let i = 0; i < 8; i++) {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    await fetch(bestServer.pingUrl + `?size=100&t=${Date.now()}-${i}`, {
                        signal: controller.signal,
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const ping = endTime - startTime;
                    
                    if (ping > 1 && ping < 2000) {
                        pings.push(ping);
                        
                        if (pings.length > 1) {
                            const jitter = Math.abs(pings[pings.length - 1] - pings[pings.length - 2]);
                            jitterSamples.push(jitter);
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                } catch (error) {
                    pings.push(50);
                }
            }
            
            if (pings.length === 0) {
                return { ping: 50, jitter: 5 };
            }
            
            pings.sort((a, b) => a - b);
            const medianPing = pings[Math.floor(pings.length / 2)];
            
            let jitter = 1;
            if (jitterSamples.length > 0) {
                jitter = jitterSamples.reduce((a, b) => a + b, 0) / jitterSamples.length;
            }
            
            return {
                ping: Math.round(medianPing),
                jitter: Math.round(jitter * 10) / 10
            };
        }
        
        function getConnectionBadge(type, tech) {
            let badgeClass = 'badge-unknown';
            let badgeText = tech || type;
            
            if (tech === '5G') {
                badgeClass = 'badge-5g';
                badgeText = '5G';
            } else if (tech === '4G/LTE') {
                badgeClass = 'badge-4g';
                badgeText = '4G/LTE';
            } else if (type === 'WiFi' || tech === 'WiFi') {
                badgeClass = 'badge-wifi';
                badgeText = 'WiFi';
            } else if (tech === 'Ethernet' || type === 'Wired') {
                badgeClass = 'badge-ethernet';
                badgeText = 'Ethernet';
            }
            // Note: Removed 3G badge
            
            return `<span class="connection-badge ${badgeClass}">${badgeText}</span>`;
        }
        
        // IMPROVED: Update speed display to handle high speeds
        function updateSpeedDisplay(speed) {
            const speedValue = document.getElementById('speedValue');
            const speedStatus = document.getElementById('speedStatus');
            
            speedValue.className = 'speed-value ';
            speedStatus.className = 'result-status';
            
            if (speed > 500) {
                speedValue.classList.add('speed-ultra');
                speedStatus.textContent = 'Ultra-Fast Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 200) {
                speedValue.classList.add('speed-excellent');
                speedStatus.textContent = 'Excellent Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 100) {
                speedValue.classList.add('speed-excellent');
                speedStatus.textContent = 'Very Fast Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 50) {
                speedValue.classList.add('speed-good');
                speedStatus.textContent = 'Fast Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 25) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Good Connection';
                speedStatus.classList.add('result-status-good');
            } else if (speed > 10) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Fair Connection';
                speedStatus.classList.add('result-status-good');
            } else if (speed > 3) {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Slow Connection';
                speedStatus.classList.add('result-status-slow');
            } else {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Very Slow Connection';
                speedStatus.classList.add('result-status-slow');
            }
            
            speedValue.innerHTML = `${speed.toFixed(1)} <span style="font-size: 0.5em;">Mbps</span>`;
        }
        
        function updateQualityIndicators(results) {
            const pingQuality = document.getElementById('pingQuality');
            if (results.ping < 20) {
                pingQuality.textContent = 'Excellent';
                pingQuality.style.color = '#2E7D32';
            } else if (results.ping < 40) {
                pingQuality.textContent = 'Very Good';
                pingQuality.style.color = '#4CAF50';
            } else if (results.ping < 60) {
                pingQuality.textContent = 'Good';
                pingQuality.style.color = '#FF9800';
            } else if (results.ping < 100) {
                pingQuality.textContent = 'Fair';
                pingQuality.style.color = '#FF9800';
            } else {
                pingQuality.textContent = 'Poor';
                pingQuality.style.color = '#F44336';
            }
            
            const jitterQuality = document.getElementById('jitterQuality');
            if (results.jitter < 5) {
                jitterQuality.textContent = 'Excellent';
                jitterQuality.style.color = '#2E7D32';
            } else if (results.jitter < 10) {
                jitterQuality.textContent = 'Good';
                jitterQuality.style.color = '#4CAF50';
            } else if (results.jitter < 20) {
                jitterQuality.textContent = 'Fair';
                jitterQuality.style.color = '#FF9800';
            } else {
                jitterQuality.textContent = 'Poor';
                jitterQuality.style.color = '#F44336';
            }
        }
        
        function updateStage(stageId) {
            document.querySelectorAll('.test-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            document.getElementById(stageId).classList.add('active');
        }
        
        // Scroll results into view
        function scrollToResults() {
            const speedResult = document.getElementById('speedResult');
            speedResult.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
        }
        
        async function startSpeedTest() {
            if (testInProgress || !bestServer) return;
            
            const resultDiv = document.getElementById('speedResult');
            const testButton = document.getElementById('testButton');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const statusMessage = document.getElementById('statusMessage');
            const serverSelection = document.getElementById('serverSelection');
            
            testInProgress = true;
            testButton.disabled = true;
            testButton.textContent = 'Testing in Progress...';
            resultDiv.style.display = 'none';
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            serverSelection.style.display = 'none';
            
            document.querySelectorAll('.test-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            
            try {
                updateStage('stageLocation');
                statusMessage.textContent = 'Initializing connection to selected server...';
                progressBar.style.width = '10%';
                
                if (!userLocation) {
                    userLocation = await detectUserLocation();
                }
                
                // Update location display
                updateLocationDisplay(userLocation);
                
                // Update results display with accurate location
                let detailedLocation = '';
                if (userLocation.city !== 'Unknown' && userLocation.region !== 'Unknown' && userLocation.country !== 'Unknown') {
                    detailedLocation = `${userLocation.city}, ${userLocation.region}, ${userLocation.country}`;
                } else if (userLocation.city !== 'Unknown' && userLocation.country !== 'Unknown') {
                    detailedLocation = `${userLocation.city}, ${userLocation.country}`;
                } else if (userLocation.country !== 'Unknown') {
                    detailedLocation = userLocation.country;
                } else {
                    detailedLocation = 'Detected from connection data';
                }
                
                document.getElementById('detectedLocation').innerHTML = 
                    `<strong>Your Location:</strong> ${detailedLocation}`;
                
                if (userLocation.isp !== 'Unknown' && userLocation.isp !== 'Unknown ISP') {
                    document.getElementById('ispInfo').innerHTML = `<strong>ISP:</strong> ${userLocation.isp}`;
                }
                
                updateStage('stagePing');
                statusMessage.textContent = 'Measuring connection quality...';
                progressBar.style.width = '25%';
                
                const latencyResults = await performLatencyTest();
                document.getElementById('pingValue').textContent = latencyResults.ping + ' ms';
                document.getElementById('jitterValue').textContent = latencyResults.jitter + ' ms';
                updateQualityIndicators(latencyResults);
                
                updateStage('stageDownload');
                statusMessage.textContent = 'Testing download speed...';
                progressBar.style.width = '50%';
                
                const downloadSpeed = await testDownloadSpeed();
                document.getElementById('downloadSpeed').textContent = downloadSpeed.toFixed(1) + ' Mbps';
                document.getElementById('speedValue').textContent = downloadSpeed.toFixed(1);
                progressBar.style.width = '75%';
                
                updateStage('stageUpload');
                statusMessage.textContent = 'Testing upload speed...';
                
                const uploadSpeed = await testUploadSpeed();
                document.getElementById('uploadSpeed').textContent = uploadSpeed.toFixed(1) + ' Mbps';
                progressBar.style.width = '90%';
                
                updateStage('stageComplete');
                statusMessage.textContent = 'Analyzing connection type...';
                progressBar.style.width = '100%';
                
                const connectionInfo = await detectConnectionType(
                    downloadSpeed,
                    uploadSpeed,
                    latencyResults.ping,
                    latencyResults.jitter
                );
                
                detectedConnectionType = connectionInfo.type;
                detectedNetworkTech = connectionInfo.technology;
                
                const badge = getConnectionBadge(connectionInfo.type, connectionInfo.technology);
                document.getElementById('connectionType').innerHTML = 
                    `<strong>Connection Type:</strong> ${connectionInfo.type} ${badge}`;
                
                document.getElementById('networkType').innerHTML = 
                    `<strong>Network Technology:</strong> ${connectionInfo.technology}`;
                
                if (connectionInfo.confidence > 70) {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> High (${connectionInfo.confidence}%)`;
                } else if (connectionInfo.confidence > 40) {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> Moderate (${connectionInfo.confidence}%)`;
                } else {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> Low - using best estimate`;
                }
                
                updateSpeedDisplay(downloadSpeed);
                
                setTimeout(() => {
                    resultDiv.style.display = 'block';
                    progressContainer.style.display = 'none';
                    testButton.disabled = false;
                    testButton.textContent = 'Run New Test';
                    testInProgress = false;
                    serverSelection.style.display = 'block';
                    statusMessage.textContent = 'Test complete! Select a different server to test again.';
                    
                    // Scroll results into view
                    scrollToResults();
                }, 800);
                
            } catch (error) {
                statusMessage.textContent = 'Test failed. Please check your connection and try again.';
                console.error('Speed test error:', error);
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                testInProgress = false;
                progressContainer.style.display = 'none';
                serverSelection.style.display = 'block';
            }
        }
        
        // Main initialization function
        async function initializeApp() {
            const preloader = document.getElementById('preloader');
            const testButton = document.getElementById('testButton');
            
            updateLoadingProgress(5);
            await new Promise(resolve => setTimeout(resolve, 300));
            
            updateLoadingProgress(15);
            await new Promise(resolve => setTimeout(resolve, 200));
            
            updateLoadingProgress(25);
            
            try {
                // Detect user location
                userLocation = await detectUserLocation();
                
                // Update location display
                updateLocationDisplay(userLocation);
                
                updateLoadingProgress(60);
                
                // Find and test closest servers
                const candidates = await findAndTestServerOptions(userLocation);
                serverCandidates = candidates;
                
                updateLoadingProgress(100);
                
            } catch (error) {
                console.log('Background initialization failed:', error);
                updateLoadingProgress(100);
                
                // Show error state
                const statusMessage = document.getElementById('statusMessage');
                statusMessage.textContent = 'Unable to detect location. Please try again.';
                testButton.disabled = false;
                testButton.textContent = 'Try Again';
                testButton.onclick = () => location.reload();
            }
            
            setTimeout(() => {
                preloader.classList.add('hidden');
            }, 500);
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            // Check for required permissions first
            const permissionsGranted = checkPermissions();
            
            if (permissionsGranted) {
                initializeApp();
            }
        });
    </script>
</body>
</html>
