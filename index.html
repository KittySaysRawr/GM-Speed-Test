<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Speed Checker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --green-primary: #4CAF50;
            --green-dark: #2E7D32;
            --green-light: #C8E6C9;
            --amber: #FF9800;
            --red: #F44336;
            --text-dark: #333;
            --text-light: #fff;
            --bg-light: #f5f5f5;
            --bg-dark: #263238;
            --blue: #2196F3;
            --purple: #9C27B0;
            --teal: #009688;
            --chart-green: #4CAF50;
            --chart-blue: #2196F3;
            --chart-orange: #FF9800;
            --chart-purple: #9C27B0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg-light);
            color: var(--text-dark);
            transition: all 0.3s ease;
            min-height: 100vh;
        }
        
        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-light);
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 30px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .dark-mode .container {
            background: #37474F;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 25px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .dark-mode .header {
            border-bottom-color: #455A64;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
            color: var(--green-dark);
        }
        
        .dark-mode .header h1 {
            color: var(--green-light);
        }
        
        .header p {
            margin: 0;
            color: #666;
            font-size: 1.1em;
        }
        
        .dark-mode .header p {
            color: #ccc;
        }
        
        .location-info {
            background: var(--green-light);
            padding: 20px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            font-size: 0.95em;
        }
        
        .dark-mode .location-info {
            background: #1B5E20;
        }
        
        .location-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        
        .location-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            min-width: 300px;
            justify-content: space-between;
        }
        
        .dark-mode .location-row {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .location-text {
            font-weight: 500;
            flex-grow: 1;
            text-align: left;
        }
        
        .flag-icon {
            width: 24px;
            height: 18px;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .test-progress-container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            display: none;
        }
        
        .dark-mode .test-progress-container {
            background: #455A64;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .test-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }
        
        .test-phase {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-dark);
        }
        
        .dark-mode .test-phase {
            color: var(--text-light);
        }
        
        .test-phase-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            background: var(--green-light);
            color: var(--green-dark);
        }
        
        .dark-mode .test-phase-badge {
            background: #1B5E20;
            color: var(--green-light);
        }
        
        .test-phase-badge.testing {
            background: var(--blue);
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .test-phase-badge.completed {
            background: var(--green-primary);
            color: white;
        }
        
        .test-phase-badge.waiting {
            background: #e0e0e0;
            color: #666;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .speed-graph-container {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            height: 200px;
            position: relative;
            overflow: hidden;
        }
        
        .dark-mode .speed-graph-container {
            background: #37474F;
        }
        
        .speed-graph {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .graph-canvas {
            width: 100%;
            height: 100%;
        }
        
        .graph-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.9);
        }
        
        .dark-mode .graph-overlay {
            background: rgba(55, 71, 79, 0.9);
        }
        
        .current-speed {
            font-size: 3em;
            font-weight: 700;
            color: var(--green-dark);
            margin-bottom: 10px;
        }
        
        .dark-mode .current-speed {
            color: var(--green-light);
        }
        
        .speed-unit {
            font-size: 1.2em;
            color: #666;
            font-weight: 500;
        }
        
        .dark-mode .speed-unit {
            color: #ccc;
        }
        
        .progress-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .progress-detail-card {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .dark-mode .progress-detail-card {
            background: #37474F;
        }
        
        .progress-detail-card.active {
            background: var(--green-light);
            border: 2px solid var(--green-primary);
        }
        
        .dark-mode .progress-detail-card.active {
            background: #1B5E20;
            border-color: var(--green-primary);
        }
        
        .progress-detail-value {
            font-size: 2em;
            font-weight: 700;
            margin: 10px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .progress-detail-value {
            color: var(--text-light);
        }
        
        .progress-detail-label {
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }
        
        .dark-mode .progress-detail-label {
            color: #ccc;
        }
        
        .test-timeline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            padding: 20px 0;
        }
        
        .timeline-track {
            position: absolute;
            top: 50%;
            left: 40px;
            right: 40px;
            height: 4px;
            background: #e0e0e0;
            transform: translateY(-50%);
            z-index: 1;
        }
        
        .timeline-progress {
            position: absolute;
            top: 50%;
            left: 40px;
            height: 4px;
            background: linear-gradient(90deg, var(--green-primary), var(--green-dark));
            transform: translateY(-50%);
            z-index: 2;
            transition: width 0.5s ease;
        }
        
        .timeline-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 3;
            flex: 1;
        }
        
        .stage-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            color: #666;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .stage-icon.completed {
            background: var(--green-primary);
            color: white;
            transform: scale(1.1);
        }
        
        .stage-icon.active {
            background: var(--blue);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 0 6px rgba(33, 150, 243, 0.2);
            animation: pulse 1.5s infinite;
        }
        
        .stage-label {
            font-size: 0.85em;
            color: #666;
            text-align: center;
            font-weight: 500;
            max-width: 80px;
        }
        
        .dark-mode .stage-label {
            color: #ccc;
        }
        
        .stage-label.active {
            color: var(--blue);
            font-weight: 600;
        }
        
        .server-selection {
            text-align: center;
            margin: 30px 0;
            padding: 25px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            display: none;
        }
        
        .dark-mode .server-selection {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .server-selection h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-dark);
        }
        
        .dark-mode .server-selection h3 {
            color: var(--text-light);
        }
        
        .server-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .server-option {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            min-width: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            max-width: 250px;
        }
        
        .server-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-color: var(--green-primary);
        }
        
        .server-option.selected {
            border-color: var(--green-primary);
            background: var(--green-light);
            transform: translateY(-3px);
        }
        
        .dark-mode .server-option {
            background: #37474F;
            border-color: #455A64;
        }
        
        .dark-mode .server-option.selected {
            background: #1B5E20;
            border-color: var(--green-primary);
        }
        
        .server-option-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        
        .server-option-ping {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
            min-height: 20px;
        }
        
        .dark-mode .server-option-ping {
            color: #ccc;
        }
        
        .server-option-location {
            font-size: 0.85em;
            color: #888;
        }
        
        .dark-mode .server-option-location {
            color: #aaa;
        }
        
        .server-flag {
            width: 24px;
            height: 18px;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .distance-near { color: #4CAF50; }
        .distance-medium { color: #FF9800; }
        .distance-far { color: #F44336; }
        
        .test-button {
            background: linear-gradient(135deg, var(--green-primary), var(--green-dark));
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            transition: all 0.3s ease;
            font-weight: bold;
            letter-spacing: 0.5px;
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
        }
        
        .test-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }
        
        .test-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }
        
        .theme-toggle:hover {
            transform: rotate(30deg);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }
        
        #speedResult {
            display: none;
            text-align: center;
            padding: 40px 30px;
            margin: 30px 0;
            border-radius: 16px;
            background: var(--green-light);
            animation: fadeIn 0.8s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .dark-mode #speedResult {
            background: #1B5E20;
        }
        
        .speed-value {
            font-size: 4em;
            font-weight: bold;
            margin: 20px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .speed-value {
            color: var(--text-light);
        }
        
        .speed-good { color: var(--green-dark); }
        .speed-medium { color: var(--amber); }
        .speed-slow { color: var(--red); }
        .speed-excellent { color: var(--blue); }
        .speed-ultra { color: var(--purple); }
        
        .result-status {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 40px;
            padding: 12px 30px;
            border-radius: 30px;
            display: inline-block;
        }
        
        .result-status-excellent {
            background-color: rgba(46, 125, 50, 0.15);
            color: var(--green-dark);
            border: 2px solid rgba(46, 125, 50, 0.3);
        }
        
        .dark-mode .result-status-excellent {
            background-color: rgba(76, 175, 80, 0.2);
            color: #C8E6C9;
            border: 2px solid rgba(76, 175, 80, 0.4);
        }
        
        .result-status-good {
            background-color: rgba(255, 152, 0, 0.15);
            color: #EF6C00;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }
        
        .dark-mode .result-status-good {
            background-color: rgba(255, 152, 0, 0.2);
            color: #FFE0B2;
            border: 2px solid rgba(255, 152, 0, 0.4);
        }
        
        .result-status-slow {
            background-color: rgba(244, 67, 54, 0.15);
            color: #D32F2F;
            border: 2px solid rgba(244, 67, 54, 0.3);
        }
        
        .dark-mode .result-status-slow {
            background-color: rgba(244, 67, 54, 0.2);
            color: #FFCDD2;
            border: 2px solid rgba(244, 67, 54, 0.4);
        }
        
        .test-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin-top: 40px;
        }
        
        .detail-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .dark-mode .detail-box {
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .detail-value {
            font-size: 2.2em;
            font-weight: bold;
            margin: 15px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .detail-value {
            color: var(--text-light);
        }
        
        .detail-label {
            font-size: 1em;
            color: #666;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .dark-mode .detail-label {
            color: #ccc;
        }
        
        .connection-info {
            text-align: center;
            margin-top: 40px;
            font-size: 0.95em;
            color: #666;
            padding: 25px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .dark-mode .connection-info {
            background: rgba(0, 0, 0, 0.3);
            color: #ccc;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .accuracy-note {
            text-align: center;
            font-size: 0.9em;
            color: #888;
            margin-top: 25px;
            font-style: italic;
        }
        
        .dark-mode .accuracy-note {
            color: #aaa;
        }
        
        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-light);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .dark-mode .preloader {
            background: var(--bg-dark);
        }
        
        .preloader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .preloader-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .loading-text {
            font-size: 1.4em;
            color: var(--text-dark);
            font-weight: 500;
            margin-bottom: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            text-align: center;
        }
        
        .dark-mode .loading-text {
            color: var(--text-light);
        }
        
        .spinner-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .spinner {
            width: 120px;
            height: 120px;
            border: 10px solid transparent;
            border-top: 10px solid var(--green-primary);
            border-right: 10px solid var(--blue);
            border-bottom: 10px solid var(--purple);
            border-left: 10px solid var(--teal);
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
            position: relative;
            box-sizing: border-box;
        }
        
        .spinner-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        
        .dark-mode .spinner-inner {
            background: #37474F;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        .spinner-percentage {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--green-dark);
            line-height: 1;
            text-align: center;
        }
        
        .dark-mode .spinner-percentage {
            color: var(--green-light);
        }
        
        @keyframes spin {
            0% { 
                transform: rotate(0deg); 
                border-top-color: var(--green-primary);
                border-right-color: var(--blue);
                border-bottom-color: var(--purple);
                border-left-color: var(--teal);
            }
            25% {
                border-top-color: var(--blue);
                border-right-color: var(--purple);
                border-bottom-color: var(--teal);
                border-left-color: var(--green-primary);
            }
            50% {
                border-top-color: var(--purple);
                border-right-color: var(--teal);
                border-bottom-color: var(--green-primary);
                border-left-color: var(--blue);
            }
            75% {
                border-top-color: var(--teal);
                border-right-color: var(--green-primary);
                border-bottom-color: var(--blue);
                border-left-color: var(--purple);
            }
            100% { 
                transform: rotate(360deg);
                border-top-color: var(--green-primary);
                border-right-color: var(--blue);
                border-bottom-color: var(--purple);
                border-left-color: var(--teal);
            }
        }
        
        .permission-request {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .permission-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
        }
        
        .dark-mode .permission-content {
            background: #37474F;
            color: var(--text-light);
        }
        
        .permission-content h3 {
            margin-top: 0;
            color: var(--green-dark);
        }
        
        .dark-mode .permission-content h3 {
            color: var(--green-light);
        }
        
        .permission-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .permission-btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .permission-btn.allow {
            background: linear-gradient(135deg, var(--green-primary), var(--green-dark));
            color: white;
        }
        
        .permission-btn.allow:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .permission-btn.deny {
            background: #e0e0e0;
            color: #333;
        }
        
        .permission-btn.deny:hover {
            background: #cccccc;
            transform: translateY(-2px);
        }
        
        .dark-mode .permission-btn.deny {
            background: #455A64;
            color: var(--text-light);
        }
        
        .dark-mode .permission-btn.deny:hover {
            background: #546E7A;
        }
        
        .error-message {
            text-align: center;
            padding: 20px;
            margin: 20px 0;
            background: #ffebee;
            border-radius: 8px;
            color: #c62828;
            display: none;
        }
        
        .dark-mode .error-message {
            background: #3f1f1f;
            color: #ffcdd2;
        }
        
        .test-progress-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
            text-align: center;
        }
        
        .dark-mode .test-progress-text {
            color: #ccc;
        }
        
        .test-time-remaining {
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
            text-align: center;
        }
        
        .dark-mode .test-time-remaining {
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="preloader" id="preloader">
        <div class="preloader-content">
            <div class="loading-text" id="loadingText">Initializing speed test...</div>
            <div class="spinner-container">
                <div class="spinner"></div>
                <div class="spinner-inner">
                    <div class="spinner-percentage" id="loadingPercentage">0%</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="permission-request" id="locationPermissionRequest">
        <div class="permission-content">
            <h3>Location Access Required</h3>
            <p>For accurate speed testing, we need to know your location to find the nearest test servers.</p>
            <p>This allows us to show you servers with the lowest ping times for the most accurate results.</p>
            <div class="permission-buttons">
                <button class="permission-btn allow" onclick="allowLocationPermission()">Allow Location Access</button>
                <button class="permission-btn deny" onclick="denyLocationPermission()">Continue Without Location</button>
            </div>
        </div>
    </div>
    
    <button class="theme-toggle" onclick="toggleTheme()">
        <i class="fas fa-moon"></i>
    </button>
    
    <div class="container">
        <div class="header">
            <h1>Internet Speed Checker</h1>
            <p>Test your connection speed with real-time graphical analysis</p>
        </div>
        
        <div class="error-message" id="errorMessage">
            <h3><i class="fas fa-exclamation-triangle"></i> Connection Error</h3>
            <p id="errorText">Unable to connect to test servers. Please check your internet connection and try again.</p>
            <button class="test-button" onclick="retryInitialization()" style="margin: 15px auto; padding: 12px 30px; font-size: 1em;">Retry Connection</button>
        </div>
        
        <div class="location-info" id="locationInfo">
            <div class="location-display">
                <div class="location-row">
                    <span class="location-text" id="userLocation">Detecting your location...</span>
                    <span class="flag-icon" id="userFlag"></span>
                </div>
                <div class="location-row">
                    <span class="location-text" id="testServer">Select a test server below</span>
                    <span class="flag-icon" id="serverFlag"></span>
                </div>
            </div>
        </div>
        
        <div class="server-selection" id="serverSelection">
            <h3>Select a Test Server</h3>
            <p>Servers are sorted by distance from your location. Choose the closest server for best results:</p>
            <div class="server-options" id="serverOptions">
                <!-- Server options will be added here dynamically -->
            </div>
        </div>
        
        <div class="test-progress-container" id="testProgressContainer">
            <div class="test-progress-header">
                <div class="test-phase" id="testPhase">Initializing Test...</div>
                <div class="test-phase-badge" id="testPhaseBadge">Starting</div>
            </div>
            
            <div class="speed-graph-container">
                <div class="speed-graph" id="speedGraph">
                    <canvas class="graph-canvas" id="graphCanvas"></canvas>
                    <div class="graph-overlay" id="graphOverlay">
                        <div class="current-speed" id="currentSpeed">0.0</div>
                        <div class="speed-unit" id="speedUnit">Mbps</div>
                    </div>
                </div>
            </div>
            
            <div class="progress-details" id="progressDetails">
                <div class="progress-detail-card" id="progressCardDownload">
                    <div class="progress-detail-label">DOWNLOAD SPEED</div>
                    <div class="progress-detail-value" id="progressDownload">--</div>
                    <div class="progress-detail-label" id="downloadStatus">Waiting</div>
                    <div class="test-progress-text" id="downloadProgressText"></div>
                    <div class="test-time-remaining" id="downloadTimeRemaining"></div>
                </div>
                <div class="progress-detail-card" id="progressCardUpload">
                    <div class="progress-detail-label">UPLOAD SPEED</div>
                    <div class="progress-detail-value" id="progressUpload">--</div>
                    <div class="progress-detail-label" id="uploadStatus">Waiting</div>
                    <div class="test-progress-text" id="uploadProgressText"></div>
                    <div class="test-time-remaining" id="uploadTimeRemaining"></div>
                </div>
            </div>
            
            <div class="test-timeline">
                <div class="timeline-track"></div>
                <div class="timeline-progress" id="timelineProgress"></div>
                
                <div class="timeline-stage">
                    <div class="stage-icon" id="stageIconLocation">
                        <i class="fas fa-map-marker-alt"></i>
                    </div>
                    <div class="stage-label" id="stageLabelLocation">Server</div>
                </div>
                
                <div class="timeline-stage">
                    <div class="stage-icon" id="stageIconDownload">
                        <i class="fas fa-download"></i>
                    </div>
                    <div class="stage-label" id="stageLabelDownload">Download</div>
                </div>
                
                <div class="timeline-stage">
                    <div class="stage-icon" id="stageIconUpload">
                        <i class="fas fa-upload"></i>
                    </div>
                    <div class="stage-label" id="stageLabelUpload">Upload</div>
                </div>
                
                <div class="timeline-stage">
                    <div class="stage-icon" id="stageIconComplete">
                        <i class="fas fa-chart-bar"></i>
                    </div>
                    <div class="stage-label" id="stageLabelComplete">Results</div>
                </div>
            </div>
        </div>
        
        <button class="test-button" onclick="startSpeedTest()" id="testButton" disabled>Finding Servers...</button>
        
        <div id="speedResult" class="speed-result">
            <h2>Connection Analysis Results</h2>
            <div id="speedValue" class="speed-value">--</div>
            <div id="speedStatus" class="result-status">--</div>
            
            <div class="test-details">
                <div class="detail-box">
                    <div class="detail-value" id="downloadSpeed">--</div>
                    <div class="detail-label">DOWNLOAD SPEED</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="uploadSpeed">--</div>
                    <div class="detail-label">UPLOAD SPEED</div>
                </div>
            </div>
            
            <div class="connection-info">
                <div id="ispInfo"><strong>ISP:</strong> --</div>
                <div id="detectedLocation" style="margin-top: 12px;"><strong>Your Location:</strong> --</div>
                <div id="testServerInfo" style="margin-top: 12px;"><strong>Test Server:</strong> --</div>
            </div>
        </div>
    </div>

    <script>
        // Theme toggle
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }
        
        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
        
        // Fun loading messages
        const loadingMessages = [
            "Initializing speed test...",
            "Preparing test servers...",
            "Checking network connectivity...",
            "Configuring test parameters...",
            "Establishing secure connection...",
            "Calibrating measurement tools...",
            "Optimizing for your location...",
            "Almost ready to start...",
            "Ready to test your connection!"
        ];
        
        // Location cache
        const LOCATION_CACHE_KEY = 'speedtest_location_cache';
        const LOCATION_CACHE_TTL = 30 * 60 * 1000;
        
        // Graph variables
        let speedData = [];
        let maxDataPoints = 80; // Increased for longer tests
        let currentTestType = null;
        let startTime = null;
        let lastUpdateTime = 0;
        let graphUpdateInterval = null;
        let testBytesTransferred = 0;
        let lastBytesUpdateTime = 0;
        
        // Test variables - UPDATED FOR LONGER TESTS
        let testInProgress = false;
        let userLocation = null;
        let bestServer = null;
        let loadingProgress = 0;
        let serverDistances = new Map();
        let locationPermissionGranted = false;
        let initializationAttempted = false;
        let downloadTestDuration = 8000; // Increased from 5000 to 8000ms
        let uploadTestDuration = 7000;   // Increased from 5000 to 7000ms
        
        // Country code to flag mapping
        const countryFlagMap = {
            'GB': 'gb', 'UK': 'gb', 'US': 'us', 'DE': 'de', 'JP': 'jp',
            'FR': 'fr', 'CA': 'ca', 'AU': 'au', 'BR': 'br', 'IN': 'in',
            'CN': 'cn', 'RU': 'ru', 'IT': 'it', 'ES': 'es', 'NL': 'nl',
            'SE': 'se', 'NO': 'no', 'DK': 'dk', 'FI': 'fi', 'PL': 'pl',
            'IE': 'ie', 'CH': 'ch', 'BE': 'be', 'AT': 'at', 'PT': 'pt',
            'SG': 'sg', 'HK': 'hk', 'KR': 'kr', 'TW': 'tw', 'MX': 'mx'
        };
        
        // Server database with global distribution - IMPROVED WITH BETTER LOCATIONS AND LARGER FILES
        const testServers = [
            { 
                id: 'cdn_na_west', 
                name: "San Francisco, USA", 
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=50000000", // Increased from 20MB to 50MB
                uploadUrl: "https://httpbin.org/post",
                country: "United States",
                countryCode: "US",
                city: "San Francisco",
                lat: 37.7749,
                lon: -122.4194,
                region: "na",
                description: "Cloudflare West Coast"
            },
            { 
                id: 'cdn_na_east', 
                name: "New York, USA", 
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "United States",
                countryCode: "US",
                city: "New York",
                lat: 40.7128,
                lon: -74.0060,
                region: "na",
                description: "Cloudflare East Coast"
            },
            { 
                id: 'cdn_eu_west', 
                name: "Amsterdam, Netherlands", 
                downloadUrl: "https://eu.speed.cloudflare.com/__down?bytes=50000000", // Increased from 20MB to 50MB
                uploadUrl: "https://httpbin.org/post",
                country: "Netherlands",
                countryCode: "NL",
                city: "Amsterdam",
                lat: 52.3676,
                lon: 4.9041,
                region: "eu",
                description: "Cloudflare Europe"
            },
            { 
                id: 'cdn_eu_central', 
                name: "Frankfurt, Germany", 
                downloadUrl: "https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Germany",
                countryCode: "DE",
                city: "Frankfurt",
                lat: 50.1109,
                lon: 8.6821,
                region: "eu",
                description: "jsDelivr Central Europe"
            },
            { 
                id: 'cdn_uk', 
                name: "London, UK", 
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "United Kingdom",
                countryCode: "GB",
                city: "London",
                lat: 51.5074,
                lon: -0.1278,
                region: "eu",
                description: "Cloudflare UK"
            },
            { 
                id: 'cdn_asia_sg', 
                name: "Singapore", 
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Singapore",
                countryCode: "SG",
                city: "Singapore",
                lat: 1.3521,
                lon: 103.8198,
                region: "asia",
                description: "Cloudflare Asia"
            },
            { 
                id: 'cdn_asia_jp', 
                name: "Tokyo, Japan", 
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Japan",
                countryCode: "JP",
                city: "Tokyo",
                lat: 35.6762,
                lon: 139.6503,
                region: "asia",
                description: "Cloudflare Japan"
            },
            { 
                id: 'cdn_au', 
                name: "Sydney, Australia", 
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Australia",
                countryCode: "AU",
                city: "Sydney",
                lat: -33.8688,
                lon: 151.2093,
                region: "au",
                description: "Cloudflare Australia"
            },
            { 
                id: 'cdn_sa', 
                name: "São Paulo, Brazil", 
                downloadUrl: "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Brazil",
                countryCode: "BR",
                city: "São Paulo",
                lat: -23.5505,
                lon: -46.6333,
                region: "sa",
                description: "Cloudflare South America"
            },
            { 
                id: 'cdn_global', 
                name: "Global Network", 
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=30000000", // Increased from 10MB to 30MB
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                countryCode: "GL",
                city: "Anycast Network",
                lat: null,
                lon: null,
                region: "global",
                description: "Global anycast network"
            }
        ];
        
        // Region mapping based on country codes
        const regionByCountryCode = {
            // North America
            'US': 'na', 'CA': 'na', 'MX': 'na',
            // Europe
            'GB': 'eu', 'UK': 'eu', 'DE': 'eu', 'FR': 'eu', 'IT': 'eu', 'ES': 'eu', 'NL': 'eu',
            'SE': 'eu', 'NO': 'eu', 'DK': 'eu', 'FI': 'eu', 'PL': 'eu', 'IE': 'eu', 'CH': 'eu',
            'BE': 'eu', 'AT': 'eu', 'PT': 'eu', 'GR': 'eu',
            // Asia
            'CN': 'asia', 'JP': 'asia', 'IN': 'asia', 'RU': 'asia', 'KR': 'asia', 'SG': 'asia',
            'TH': 'asia', 'VN': 'asia', 'MY': 'asia', 'ID': 'asia', 'PH': 'asia', 'HK': 'asia',
            'TW': 'asia',
            // Australia/Oceania
            'AU': 'au', 'NZ': 'au',
            // South America
            'BR': 'sa', 'AR': 'sa', 'CL': 'sa', 'CO': 'sa', 'PE': 'sa',
            // Africa
            'ZA': 'africa', 'NG': 'africa', 'EG': 'africa', 'KE': 'africa'
        };
        
        // Show error message
        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            errorText.textContent = message;
            errorMessage.style.display = 'block';
        }
        
        // Hide error message
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
        
        // Retry initialization
        function retryInitialization() {
            hideError();
            document.getElementById('testButton').disabled = true;
            document.getElementById('testButton').textContent = 'Finding Servers...';
            initializeApp();
        }
        
        // Initialize speed graph
        function initializeSpeedGraph() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            speedData = [];
            drawGraph(ctx);
        }
        
        // Draw the speed graph
        function drawGraph(ctx) {
            const canvas = ctx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (speedData.length < 2) {
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(20, height / 2);
                ctx.lineTo(width - 20, height / 2);
                ctx.stroke();
                ctx.setLineDash([]);
                return;
            }
            
            const maxSpeed = Math.max(...speedData.map(d => d.speed), 1);
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const y = height - 20 - (i * (height - 40) / 5);
                ctx.beginPath();
                ctx.moveTo(20, y);
                ctx.lineTo(width - 20, y);
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText((maxSpeed * i / 5).toFixed(1), 15, y + 4);
            }
            
            const timeSpan = speedData[speedData.length - 1].time - speedData[0].time;
            
            for (let i = 0; i <= 5; i++) {
                const x = 20 + (i * (width - 40) / 5);
                ctx.beginPath();
                ctx.moveTo(x, 20);
                ctx.lineTo(x, height - 20);
                ctx.stroke();
                
                if (timeSpan > 0) {
                    const time = (timeSpan * i / 5).toFixed(1);
                    ctx.fillStyle = '#666';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(time + 's', x, height - 5);
                }
            }
            
            ctx.strokeStyle = currentTestType === 'download' ? 'var(--chart-green)' : 'var(--chart-blue)';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            const firstPoint = speedData[0];
            const x1 = 20 + ((firstPoint.time - speedData[0].time) / timeSpan) * (width - 40);
            const y1 = height - 20 - (firstPoint.speed / maxSpeed) * (height - 40);
            ctx.moveTo(x1, y1);
            
            for (let i = 1; i < speedData.length; i++) {
                const point = speedData[i];
                const x = 20 + ((point.time - speedData[0].time) / timeSpan) * (width - 40);
                const y = height - 20 - (point.speed / maxSpeed) * (height - 40);
                ctx.lineTo(x, y);
            }
            
            ctx.stroke();
            
            if (speedData.length > 1) {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                if (currentTestType === 'download') {
                    gradient.addColorStop(0, 'rgba(76, 175, 80, 0.3)');
                    gradient.addColorStop(1, 'rgba(76, 175, 80, 0.1)');
                } else {
                    gradient.addColorStop(0, 'rgba(33, 150, 243, 0.3)');
                    gradient.addColorStop(1, 'rgba(33, 150, 243, 0.1)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(20, height - 20);
                
                for (let i = 0; i < speedData.length; i++) {
                    const point = speedData[i];
                    const x = 20 + ((point.time - speedData[0].time) / timeSpan) * (width - 40);
                    const y = height - 20 - (point.speed / maxSpeed) * (height - 40);
                    ctx.lineTo(x, y);
                }
                
                const lastX = 20 + ((speedData[speedData.length - 1].time - speedData[0].time) / timeSpan) * (width - 40);
                ctx.lineTo(lastX, height - 20);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // Add data point to graph with throttling
        function addSpeedDataPoint(speed) {
            const now = Date.now();
            if (!startTime) {
                startTime = now;
                lastUpdateTime = now;
            }
            
            const time = (now - startTime) / 1000;
            
            speedData.push({
                speed: speed,
                time: time
            });
            
            if (speedData.length > maxDataPoints) {
                speedData.shift();
            }
            
            // Update the current speed display
            document.getElementById('currentSpeed').textContent = speed.toFixed(1);
            
            // Update progress value
            if (currentTestType === 'download') {
                document.getElementById('progressDownload').textContent = speed.toFixed(1) + ' Mbps';
            } else if (currentTestType === 'upload') {
                document.getElementById('progressUpload').textContent = speed.toFixed(1) + ' Mbps';
            }
            
            // Draw the graph
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            drawGraph(ctx);
            
            lastUpdateTime = now;
        }
        
        // Reset graph for new test
        function resetGraph(testType) {
            currentTestType = testType;
            speedData = [];
            startTime = Date.now();
            lastUpdateTime = 0;
            testBytesTransferred = 0;
            lastBytesUpdateTime = Date.now();
            
            const unitElement = document.getElementById('speedUnit');
            const phaseBadge = document.getElementById('testPhaseBadge');
            
            if (testType === 'download') {
                unitElement.textContent = 'Mbps';
                phaseBadge.textContent = 'Downloading';
                phaseBadge.className = 'test-phase-badge testing';
                document.getElementById('testPhase').textContent = 'Testing Download Speed';
                document.getElementById('downloadStatus').textContent = 'Testing';
            } else if (testType === 'upload') {
                unitElement.textContent = 'Mbps';
                phaseBadge.textContent = 'Uploading';
                phaseBadge.className = 'test-phase-badge testing';
                document.getElementById('testPhase').textContent = 'Testing Upload Speed';
                document.getElementById('uploadStatus').textContent = 'Testing';
            }
            
            document.getElementById('graphOverlay').style.display = 'flex';
            document.getElementById('currentSpeed').textContent = '0.0';
            
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            drawGraph(ctx);
        }
        
        // Update progress card
        function updateProgressCard(type, value, status) {
            const card = document.getElementById(`progressCard${type.charAt(0).toUpperCase() + type.slice(1)}`);
            const valueElement = document.getElementById(`progress${type.charAt(0).toUpperCase() + type.slice(1)}`);
            const statusElement = document.getElementById(`${type}Status`);
            
            if (value !== undefined) {
                valueElement.textContent = value.toFixed(1) + ' Mbps';
            }
            
            if (status) {
                statusElement.textContent = status;
                card.classList.remove('active');
                if (status === 'Testing' || status === 'Completed') {
                    card.classList.add('active');
                }
            }
        }
        
        // Update timeline progress
        function updateTimelineProgress(progress) {
            const timelineProgress = document.getElementById('timelineProgress');
            const width = Math.min(Math.max(progress, 0), 100);
            timelineProgress.style.width = `${width}%`;
        }
        
        // Update stage icons
        function updateStage(stageId) {
            document.querySelectorAll('.stage-icon').forEach(icon => {
                icon.className = 'stage-icon';
                const iconType = icon.querySelector('i').className;
                icon.innerHTML = `<i class="${iconType}"></i>`;
            });
            
            document.querySelectorAll('.stage-label').forEach(label => {
                label.classList.remove('active');
            });
            
            const stageIcon = document.getElementById(`stageIcon${stageId.charAt(0).toUpperCase() + stageId.slice(1)}`);
            const stageLabel = document.getElementById(`stageLabel${stageId.charAt(0).toUpperCase() + stageId.slice(1)}`);
            
            if (stageIcon) {
                stageIcon.classList.add('active');
            }
            if (stageLabel) {
                stageLabel.classList.add('active');
            }
            
            const stages = ['Location', 'Download', 'Upload', 'Complete'];
            const currentIndex = stages.indexOf(stageId.charAt(0).toUpperCase() + stageId.slice(1));
            
            for (let i = 0; i < currentIndex; i++) {
                const completedIcon = document.getElementById(`stageIcon${stages[i]}`);
                if (completedIcon) {
                    completedIcon.classList.add('completed');
                }
            }
            
            const progressPercent = (currentIndex / (stages.length - 1)) * 100;
            updateTimelineProgress(progressPercent);
        }
        
        // Show progress container
        function showProgressContainer() {
            document.getElementById('testProgressContainer').style.display = 'block';
            document.getElementById('serverSelection').style.display = 'none';
            initializeSpeedGraph();
            updateProgressCard('download', 0, 'Waiting');
            updateProgressCard('upload', 0, 'Waiting');
            updateStage('location');
        }
        
        // Hide progress container
        function hideProgressContainer() {
            document.getElementById('testProgressContainer').style.display = 'none';
        }
        
        // Update loading progress
        function updateLoadingProgress(progress) {
            loadingProgress = Math.min(100, Math.max(0, progress));
            const percentageEl = document.getElementById('loadingPercentage');
            const loadingTextEl = document.getElementById('loadingText');
            
            percentageEl.textContent = `${Math.round(loadingProgress)}%`;
            
            const messageIndex = Math.min(
                Math.floor(loadingProgress / 10),
                loadingMessages.length - 1
            );
            loadingTextEl.textContent = loadingMessages[messageIndex];
            
            const spinner = document.querySelector('.spinner');
            if (loadingProgress < 30) {
                spinner.style.borderTopColor = '#FF9800';
                spinner.style.borderRightColor = '#2196F3';
                spinner.style.borderBottomColor = '#9C27B0';
                spinner.style.borderLeftColor = '#009688';
            } else if (loadingProgress < 70) {
                spinner.style.borderTopColor = '#4CAF50';
                spinner.style.borderRightColor = '#FF9800';
                spinner.style.borderBottomColor = '#2196F3';
                spinner.style.borderLeftColor = '#9C27B0';
            } else {
                spinner.style.borderTopColor = '#009688';
                spinner.style.borderRightColor = '#4CAF50';
                spinner.style.borderBottomColor = '#FF9800';
                spinner.style.borderLeftColor = '#2196F3';
            }
        }
        
        // Calculate distance - FIXED VERSION
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // If any coordinate is missing, return Infinity
            if (lat1 === null || lon1 === null || lat2 === null || lon2 === null) {
                return Infinity;
            }
            
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Convert km to miles
        function kmToMiles(km) {
            return km * 0.621371;
        }
        
        // Check if country uses miles
        function usesMiles(countryCode) {
            const mileCountries = ['US', 'GB', 'UK', 'LR', 'MM'];
            return mileCountries.includes(countryCode.toUpperCase());
        }
        
        // Format distance
        function formatDistance(distanceKm, userCountryCode) {
            if (distanceKm === Infinity || distanceKm === undefined || distanceKm === null) {
                return "Unknown distance";
            }
            
            const maxDistance = 500;
            if (distanceKm > maxDistance) {
                if (usesMiles(userCountryCode)) {
                    return "500+ mi";
                } else {
                    return "500+ km";
                }
            }
            
            let displayDistance, unit;
            if (usesMiles(userCountryCode)) {
                displayDistance = kmToMiles(distanceKm);
                unit = "mi";
            } else {
                displayDistance = distanceKm;
                unit = "km";
            }
            
            if (displayDistance < 1) {
                return `< 1 ${unit}`;
            } else if (displayDistance < 10) {
                return `${displayDistance.toFixed(1)} ${unit}`;
            } else {
                return `${Math.round(displayDistance)} ${unit}`;
            }
        }
        
        // Get distance class
        function getDistanceClass(distanceKm, userCountryCode) {
            if (distanceKm === Infinity || distanceKm === undefined || distanceKm === null) {
                return "";
            }
            
            if (usesMiles(userCountryCode)) {
                const distanceMiles = kmToMiles(distanceKm);
                const displayDistance = Math.min(distanceMiles, 500);
                
                if (displayDistance <= 150) {
                    return "distance-near";
                } else if (displayDistance <= 300) {
                    return "distance-medium";
                } else {
                    return "distance-far";
                }
            } else {
                const displayDistance = Math.min(distanceKm, 500);
                
                if (displayDistance <= 150) {
                    return "distance-near";
                } else if (displayDistance <= 300) {
                    return "distance-medium";
                } else {
                    return "distance-far";
                }
            }
        }
        
        // Get flag class
        function getFlagClass(countryCode) {
            const code = (countryCode || 'unknown').toUpperCase();
            if (countryFlagMap[code]) {
                return `flag-icon-${countryFlagMap[code]}`;
            }
            return 'flag-icon-us';
        }
        
        // Get cached location
        function getCachedLocation() {
            try {
                const cached = localStorage.getItem(LOCATION_CACHE_KEY);
                if (!cached) return null;
                
                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();
                
                if (now - timestamp < LOCATION_CACHE_TTL) {
                    return data;
                }
                
                localStorage.removeItem(LOCATION_CACHE_KEY);
                return null;
            } catch (error) {
                return null;
            }
        }
        
        // Cache location data
        function cacheLocationData(locationData) {
            try {
                const cacheData = {
                    data: locationData,
                    timestamp: Date.now()
                };
                localStorage.setItem(LOCATION_CACHE_KEY, JSON.stringify(cacheData));
            } catch (error) {
                // Ignore caching errors
            }
        }
        
        // Permission handling functions
        function allowLocationPermission() {
            document.getElementById('locationPermissionRequest').style.display = 'none';
            locationPermissionGranted = true;
            localStorage.setItem('locationPermission', 'granted');
            initializeApp();
        }
        
        function denyLocationPermission() {
            document.getElementById('locationPermissionRequest').style.display = 'none';
            locationPermissionGranted = false;
            localStorage.setItem('locationPermission', 'denied');
            initializeApp();
        }
        
        // Check for required permissions
        function checkPermissions() {
            const savedLocationPermission = localStorage.getItem('locationPermission');
            
            if (savedLocationPermission === 'granted') {
                locationPermissionGranted = true;
            }
            
            const hasGeolocation = 'geolocation' in navigator;
            
            if (hasGeolocation && !locationPermissionGranted && savedLocationPermission !== 'denied' && !initializationAttempted) {
                document.getElementById('locationPermissionRequest').style.display = 'flex';
                return false;
            }
            
            return true;
        }
        
        // Detect user location - IMPROVED VERSION
        async function detectUserLocation() {
            updateLoadingProgress(40);
            
            const cached = getCachedLocation();
            if (cached) {
                updateLoadingProgress(50);
                await new Promise(resolve => setTimeout(resolve, 300));
                return cached;
            }
            
            let locationData = {
                country: 'Unknown',
                city: 'Unknown',
                region: 'Unknown',
                latitude: null,
                longitude: null,
                isp: 'Unknown',
                method: 'unknown',
                countryCode: 'Unknown',
                accuracy: 'low',
                continent: 'Unknown'
            };
            
            try {
                updateLoadingProgress(55);
                
                // Try multiple IP geolocation services for better accuracy
                const services = [
                    'https://ipapi.co/json/',
                    'https://ipinfo.io/json',
                    'https://freegeoip.app/json/'
                ];
                
                for (const service of services) {
                    try {
                        const response = await fetch(service, {
                            signal: AbortSignal.timeout(3000)
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            
                            // Get latitude/longitude from various possible formats
                            let lat = null, lon = null;
                            
                            if (data.latitude !== undefined && data.longitude !== undefined) {
                                lat = data.latitude;
                                lon = data.longitude;
                            } else if (data.loc) {
                                const [latStr, lonStr] = data.loc.split(',');
                                lat = parseFloat(latStr);
                                lon = parseFloat(lonStr);
                            } else if (data.ll) {
                                const [latStr, lonStr] = data.ll.split(',');
                                lat = parseFloat(latStr);
                                lon = parseFloat(lonStr);
                            }
                            
                            locationData.city = data.city || data.city_name || locationData.city;
                            locationData.country = data.country_name || data.country || locationData.country;
                            locationData.countryCode = data.country_code || data.country || locationData.countryCode;
                            locationData.region = data.region || data.region_name || data.state || locationData.region;
                            locationData.latitude = lat || locationData.latitude;
                            locationData.longitude = lon || locationData.longitude;
                            locationData.isp = data.org || data.asn || data.isp || locationData.isp;
                            locationData.method = service.split('/')[2];
                            
                            // If we got valid coordinates, break
                            if (lat !== null && lon !== null) {
                                break;
                            }
                        }
                    } catch (error) {
                        // Try next service
                        continue;
                    }
                }
                
                updateLoadingProgress(65);
                
                // If we still don't have coordinates, estimate based on country
                if (locationData.latitude === null && locationData.countryCode !== 'Unknown') {
                    // Approximate coordinates for major countries
                    const countryCoordinates = {
                        'US': { lat: 39.8283, lon: -98.5795 }, // USA center
                        'GB': { lat: 54.7024, lon: -3.2766 },  // UK center
                        'DE': { lat: 51.1657, lon: 10.4515 },  // Germany center
                        'FR': { lat: 46.6031, lon: 1.8883 },   // France center
                        'JP': { lat: 36.2048, lon: 138.2529 }, // Japan center
                        'AU': { lat: -25.2744, lon: 133.7751 }, // Australia center
                        'CA': { lat: 56.1304, lon: -106.3468 }, // Canada center
                        'BR': { lat: -14.2350, lon: -51.9253 }, // Brazil center
                        'IN': { lat: 20.5937, lon: 78.9629 },   // India center
                        'CN': { lat: 35.8617, lon: 104.1954 },  // China center
                        'RU': { lat: 61.5240, lon: 105.3188 },  // Russia center
                        'MX': { lat: 23.6345, lon: -102.5528 }, // Mexico center
                        'IT': { lat: 41.8719, lon: 12.5674 },   // Italy center
                        'ES': { lat: 40.4637, lon: -3.7492 },   // Spain center
                        'NL': { lat: 52.1326, lon: 5.2913 },    // Netherlands center
                        'SE': { lat: 60.1282, lon: 18.6435 },   // Sweden center
                        'NO': { lat: 60.4720, lon: 8.4689 },    // Norway center
                        'DK': { lat: 56.2639, lon: 9.5018 },    // Denmark center
                        'FI': { lat: 61.9241, lon: 25.7482 },   // Finland center
                        'PL': { lat: 51.9194, lon: 19.1451 },   // Poland center
                        'IE': { lat: 53.1424, lon: -7.6921 },   // Ireland center
                        'CH': { lat: 46.8182, lon: 8.2275 },    // Switzerland center
                        'BE': { lat: 50.5039, lon: 4.4699 },    // Belgium center
                        'AT': { lat: 47.5162, lon: 14.5501 },   // Austria center
                        'PT': { lat: 39.3999, lon: -8.2245 },   // Portugal center
                        'GR': { lat: 39.0742, lon: 21.8243 },   // Greece center
                        'CZ': { lat: 49.8175, lon: 15.4720 },   // Czech Republic center
                        'HU': { lat: 47.1625, lon: 19.5033 },   // Hungary center
                        'RO': { lat: 45.9432, lon: 24.9668 },   // Romania center
                        'BG': { lat: 42.7339, lon: 25.4858 },   // Bulgaria center
                        'SG': { lat: 1.3521, lon: 103.8198 },   // Singapore
                        'HK': { lat: 22.3964, lon: 114.1095 },  // Hong Kong
                        'TW': { lat: 23.6978, lon: 120.9605 },  // Taiwan
                        'KR': { lat: 35.9078, lon: 127.7669 },  // South Korea
                        'MY': { lat: 4.2105, lon: 101.9758 },   // Malaysia
                        'ID': { lat: -0.7893, lon: 113.9213 },  // Indonesia
                        'TH': { lat: 15.8700, lon: 100.9925 },  // Thailand
                        'VN': { lat: 14.0583, lon: 108.2772 },  // Vietnam
                        'PH': { lat: 12.8797, lon: 121.7740 },  // Philippines
                        'NZ': { lat: -40.9006, lon: 174.8860 }, // New Zealand
                        'AR': { lat: -38.4161, lon: -63.6167 }, // Argentina
                        'CL': { lat: -35.6751, lon: -71.5430 }, // Chile
                        'CO': { lat: 4.5709, lon: -74.2973 },   // Colombia
                        'PE': { lat: -9.1900, lon: -75.0152 },  // Peru
                        'ZA': { lat: -30.5595, lon: 22.9375 },  // South Africa
                        'NG': { lat: 9.0820, lon: 8.6753 },     // Nigeria
                        'EG': { lat: 26.8206, lon: 30.8025 },   // Egypt
                        'KE': { lat: -0.0236, lon: 37.9062 }    // Kenya
                    };
                    
                    if (countryCoordinates[locationData.countryCode.toUpperCase()]) {
                        const coords = countryCoordinates[locationData.countryCode.toUpperCase()];
                        locationData.latitude = coords.lat;
                        locationData.longitude = coords.lon;
                        locationData.method = 'estimated_from_country';
                    }
                }
                
            } catch (error) {
                // Final fallback - use browser language
                updateLoadingProgress(60);
                const browserLanguage = navigator.language || 'en-US';
                const countryCode = browserLanguage.split('-')[1] || 'US';
                locationData.countryCode = countryCode;
                locationData.country = 'Detected from browser';
                locationData.method = 'browser_language';
                
                // Add estimated coordinates for browser-detected country
                const countryCoordinates = {
                    'US': { lat: 39.8283, lon: -98.5795 },
                    'GB': { lat: 54.7024, lon: -3.2766 },
                    'DE': { lat: 51.1657, lon: 10.4515 },
                    'FR': { lat: 46.6031, lon: 1.8883 },
                    'JP': { lat: 36.2048, lon: 138.2529 }
                };
                
                if (countryCoordinates[countryCode.toUpperCase()]) {
                    const coords = countryCoordinates[countryCode.toUpperCase()];
                    locationData.latitude = coords.lat;
                    locationData.longitude = coords.lon;
                }
            }
            
            updateLoadingProgress(70);
            cacheLocationData(locationData);
            
            return locationData;
        }
        
        // Find closest servers - FIXED VERSION
        function findClosestServers(userLocation, count = 6) {
            // Clear previous distances
            serverDistances.clear();
            
            // If we have coordinates, calculate distances
            if (userLocation && userLocation.latitude !== null && userLocation.longitude !== null) {
                const serversWithDistance = testServers
                    .map(server => {
                        // Calculate distance only if server has coordinates
                        let distance = Infinity;
                        if (server.lat !== null && server.lon !== null) {
                            distance = calculateDistance(
                                userLocation.latitude,
                                userLocation.longitude,
                                server.lat,
                                server.lon
                            );
                        }
                        return { server, distance };
                    })
                    .sort((a, b) => a.distance - b.distance);
                
                // Store distances for display
                serversWithDistance.forEach(item => {
                    serverDistances.set(item.server.id, item.distance);
                });
                
                // Return closest servers
                const closest = serversWithDistance
                    .slice(0, Math.min(count, serversWithDistance.length))
                    .map(item => item.server);
                
                console.log('Found closest servers based on location:', closest.map(s => s.name));
                return closest;
            }
            
            // If no coordinates, try to use country code for regional matching
            if (userLocation && userLocation.countryCode !== 'Unknown') {
                const userRegion = regionByCountryCode[userLocation.countryCode.toUpperCase()];
                
                if (userRegion) {
                    // First try servers in the same region
                    const regionalServers = testServers.filter(s => s.region === userRegion);
                    if (regionalServers.length > 0) {
                        // Add regional servers first
                        const result = regionalServers.slice(0, Math.min(3, regionalServers.length));
                        
                        // Add some diverse servers from other regions
                        const otherRegions = ['na', 'eu', 'asia', 'global'];
                        for (const region of otherRegions) {
                            if (region !== userRegion) {
                                const regionServer = testServers.find(s => s.region === region);
                                if (regionServer && !result.includes(regionServer) && result.length < count) {
                                    result.push(regionServer);
                                }
                            }
                        }
                        
                        // Set distances for regional servers as "near"
                        result.forEach(server => {
                            const distance = server.region === userRegion ? 50 : 300;
                            serverDistances.set(server.id, distance);
                        });
                        
                        console.log('Found regional servers:', result.map(s => s.name));
                        return result;
                    }
                }
            }
            
            // Fallback: diverse servers from different regions
            return getDiverseServers(count);
        }
        
        // Get diverse servers
        function getDiverseServers(count) {
            const regions = ['na', 'eu', 'asia', 'au', 'global'];
            const result = [];
            
            for (const region of regions) {
                const regionServers = testServers.filter(s => s.region === region);
                if (regionServers.length > 0) {
                    result.push(regionServers[0]);
                    if (result.length >= count) break;
                }
            }
            
            if (result.length < count) {
                const remaining = testServers
                    .filter(s => !result.includes(s))
                    .slice(0, count - result.length);
                result.push(...remaining);
            }
            
            result.forEach(server => {
                serverDistances.set(server.id, Infinity);
            });
            
            console.log('Using diverse servers:', result.map(s => s.name));
            return result;
        }
        
        // Find and test server options - IMPROVED VERSION
        async function findAndTestServerOptions(userLocation) {
            updateLoadingProgress(75);
            const testButton = document.getElementById('testButton');
            
            // Clear any previous selection
            bestServer = null;
            
            // Find closest servers based on location
            const closestServers = findClosestServers(userLocation, 6);
            
            // Create server options with distances
            createServerOptions(closestServers, userLocation.countryCode || 'US');
            
            if (closestServers.length > 0) {
                // Select the first (closest) server by default
                bestServer = closestServers[0];
                updateServerDisplay(bestServer);
                
                // Highlight the selected server in the UI
                const serverOptions = document.querySelectorAll('.server-option');
                serverOptions.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.serverId === bestServer.id) {
                        option.classList.add('selected');
                    }
                });
                
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                
                console.log('Selected best server:', bestServer.name, 'for location:', userLocation.city, userLocation.country);
            } else {
                // Fallback to global server
                bestServer = testServers.find(s => s.id === 'cdn_global') || testServers[0];
                updateServerDisplay(bestServer);
                
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                showError('Using global test server. Local servers unavailable.');
            }
            
            return closestServers.map(server => ({
                server: server,
                distance: serverDistances.get(server.id)
            }));
        }
        
        // Create server options
        function createServerOptions(servers, userCountryCode) {
            const serverSelection = document.getElementById('serverSelection');
            const serverOptions = document.getElementById('serverOptions');
            
            serverOptions.innerHTML = '';
            
            servers.forEach((server, index) => {
                const option = document.createElement('div');
                option.className = 'server-option';
                option.dataset.serverId = server.id;
                
                const flagClass = getFlagClass(server.countryCode);
                const distanceKm = serverDistances.get(server.id);
                const distanceClass = getDistanceClass(distanceKm, userCountryCode);
                const distanceText = formatDistance(distanceKm, userCountryCode);
                
                option.innerHTML = `
                    <div class="server-option-title">
                        <span class="server-flag ${flagClass}"></span>
                        ${server.name}
                    </div>
                    <div class="server-option-ping">Distance: <span class="${distanceClass}">${distanceText}</span></div>
                    <div class="server-option-location">${server.description}</div>
                `;
                
                option.addEventListener('click', () => {
                    document.querySelectorAll('.server-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    
                    option.classList.add('selected');
                    bestServer = server;
                    updateServerDisplay(server);
                    
                    console.log('User selected server:', server.name);
                });
                
                serverOptions.appendChild(option);
                
                // Select the first server by default
                if (index === 0) {
                    setTimeout(() => {
                        option.classList.add('selected');
                    }, 100);
                }
            });
            
            serverSelection.style.display = 'block';
        }
        
        // Update server display
        function updateServerDisplay(server) {
            const testServerEl = document.getElementById('testServer');
            const serverFlagEl = document.getElementById('serverFlag');
            
            let serverText = 'Test Server: ';
            if (server.country === 'Global') {
                serverText += 'Global CDN Network';
            } else {
                serverText += `${server.city}, ${server.country}`;
            }
            testServerEl.textContent = serverText;
            
            if (server.countryCode && server.countryCode !== 'GL') {
                serverFlagEl.className = `flag-icon ${getFlagClass(server.countryCode)}`;
                serverFlagEl.style.display = 'inline-block';
            } else {
                serverFlagEl.className = 'flag-icon flag-icon-globe';
                serverFlagEl.style.display = 'inline-block';
            }
            
            // Update results display as well
            let serverInfo = '';
            if (server.country === 'Global') {
                serverInfo = 'Global CDN Network';
            } else {
                serverInfo = `${server.city}, ${server.country}`;
            }
            document.getElementById('testServerInfo').innerHTML = 
                `<strong>Test Server:</strong> ${serverInfo}`;
        }
        
        // Update location display
        function updateLocationDisplay(location) {
            const userLocationEl = document.getElementById('userLocation');
            const userFlagEl = document.getElementById('userFlag');
            
            let locationText = 'Your Location: ';
            if (location.city !== 'Unknown' && location.region !== 'Unknown' && location.country !== 'Unknown') {
                locationText += `${location.city}, ${location.region}, ${location.country}`;
            } else if (location.city !== 'Unknown' && location.country !== 'Unknown') {
                locationText += `${location.city}, ${location.country}`;
            } else if (location.country !== 'Unknown') {
                locationText += location.country;
            } else {
                locationText += 'Approximate location detected';
            }
            userLocationEl.textContent = locationText;
            
            if (location.countryCode && location.countryCode !== 'Unknown') {
                userFlagEl.className = `flag-icon ${getFlagClass(location.countryCode)}`;
                userFlagEl.style.display = 'inline-block';
            } else {
                userFlagEl.style.display = 'none';
            }
            
            // Update results display as well
            let detailedLocation = '';
            if (location.city !== 'Unknown' && location.region !== 'Unknown' && location.country !== 'Unknown') {
                detailedLocation = `${location.city}, ${location.region}, ${location.country}`;
            } else if (location.city !== 'Unknown' && location.country !== 'Unknown') {
                detailedLocation = `${location.city}, ${location.country}`;
            } else if (location.country !== 'Unknown') {
                detailedLocation = location.country;
            } else {
                detailedLocation = 'Approximate location detected';
            }
            
            document.getElementById('detectedLocation').innerHTML = 
                `<strong>Your Location:</strong> ${detailedLocation}`;
            
            if (location.isp !== 'Unknown' && location.isp !== 'Unknown ISP') {
                document.getElementById('ispInfo').innerHTML = `<strong>ISP:</strong> ${location.isp}`;
            }
        }
        
        // Generate test data - UPDATED FOR LARGER FILES
        function generateTestData(size) {
            const buffer = new ArrayBuffer(size);
            const view = new Uint8Array(buffer);
            
            for (let i = 0; i < size; i++) {
                view[i] = Math.floor(Math.random() * 256);
            }
            
            return buffer;
        }
        
        // ENHANCED DOWNLOAD SPEED TEST WITH LONGER DURATION AND LARGER FILES - CAPS REMOVED
        async function testDownloadSpeed() {
            updateProgressCard('download', 0, 'Testing');
            resetGraph('download');
            
            let totalSpeed = 0;
            let speedCount = 0;
            const testDuration = downloadTestDuration; // 8 seconds now
            
            const urls = [
                "https://speed.cloudflare.com/__down?bytes=50000000&nocache=", // 50MB file
                "https://raw.githubusercontent.com/torvalds/linux/master/README?nocache=",
                "https://cdn.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js?nocache="
            ];
            
            // Start real-time graph updates
            let totalBytesDownloaded = 0;
            let testStartTime = Date.now();
            lastBytesUpdateTime = testStartTime;
            
            // Update progress text
            const downloadProgressText = document.getElementById('downloadProgressText');
            const downloadTimeRemaining = document.getElementById('downloadTimeRemaining');
            
            // Real-time update interval for the graph - every 50ms
            const updateInterval = setInterval(() => {
                const now = Date.now();
                const elapsed = (now - testStartTime) / 1000;
                const remaining = Math.max(0, (downloadTestDuration/1000) - elapsed);
                
                if (elapsed > 0 && totalBytesDownloaded > 0) {
                    const currentSpeed = (totalBytesDownloaded * 8) / (elapsed * 1024 * 1024);
                    addSpeedDataPoint(currentSpeed);
                    
                    // Update progress text
                    downloadProgressText.textContent = `Downloaded: ${formatBytes(totalBytesDownloaded)}`;
                    downloadTimeRemaining.textContent = `Time remaining: ${remaining.toFixed(1)}s`;
                }
            }, 50);
            
            try {
                // Use multiple parallel connections for better accuracy
                const parallelDownloads = 4; // Increased from 3 to 4
                const downloadPromises = [];
                
                for (let i = 0; i < parallelDownloads; i++) {
                    const url = urls[i % urls.length] + Date.now() + i;
                    downloadPromises.push(
                        fetch(url, {
                            cache: 'no-store',
                            headers: {
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            },
                            mode: 'cors'
                        }).then(async response => {
                            if (!response.ok) throw new Error(`HTTP ${response.status}`);
                            
                            const reader = response.body.getReader();
                            let chunkBytes = 0;
                            let chunkStartTime = Date.now();
                            
                            while (Date.now() - testStartTime < testDuration) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                
                                chunkBytes += value.length;
                                totalBytesDownloaded += value.length;
                                
                                // Calculate instant speed for this chunk
                                const chunkTime = (Date.now() - chunkStartTime) / 1000;
                                if (chunkTime > 0.05) {
                                    const instantSpeed = (value.length * 8) / (chunkTime * 1024 * 1024);
                                    totalSpeed += instantSpeed;
                                    speedCount++;
                                    chunkStartTime = Date.now();
                                }
                            }
                            
                            if (reader.cancel) reader.cancel();
                            return chunkBytes;
                        }).catch(error => {
                            console.log(`Download connection ${i} failed:`, error);
                            return 0;
                        })
                    );
                }
                
                // Also try a very large file download for sustained measurement
                const largeFilePromise = fetch('https://speed.cloudflare.com/__down?bytes=100000000&nocache=' + Date.now(), {
                    cache: 'no-store',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                }).then(async response => {
                    if (!response.ok) return 0;
                    
                    const reader = response.body.getReader();
                    let largeFileBytes = 0;
                    const largeFileStartTime = Date.now();
                    
                    while (Date.now() - largeFileStartTime < 6000 && Date.now() - testStartTime < testDuration) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        largeFileBytes += value.length;
                        totalBytesDownloaded += value.length;
                        
                        // Update graph with instant speed
                        const now = Date.now();
                        const elapsed = (now - largeFileStartTime) / 1000;
                        if (elapsed > 0) {
                            const currentSpeed = (largeFileBytes * 8) / (elapsed * 1024 * 1024);
                            addSpeedDataPoint(currentSpeed);
                            totalSpeed += currentSpeed;
                            speedCount++;
                        }
                    }
                    
                    if (reader.cancel) reader.cancel();
                    return largeFileBytes;
                }).catch(error => {
                    console.log('Large file download failed:', error);
                    return 0;
                });
                
                downloadPromises.push(largeFilePromise);
                
                // Wait for all downloads to complete
                await Promise.all(downloadPromises);
                
            } catch (error) {
                console.log('Download test error:', error);
            } finally {
                clearInterval(updateInterval);
                downloadProgressText.textContent = '';
                downloadTimeRemaining.textContent = '';
                
                // Calculate final average speed
                const totalElapsed = (Date.now() - testStartTime) / 1000;
                let finalSpeed = 0;
                
                if (totalElapsed > 0 && totalBytesDownloaded > 0) {
                    finalSpeed = (totalBytesDownloaded * 8) / (totalElapsed * 1024 * 1024);
                } else if (speedCount > 0) {
                    finalSpeed = totalSpeed / speedCount;
                } else {
                    // FALLBACK SPEED CAP REMOVED - was: finalSpeed = 10;
                    finalSpeed = 0.1; // Minimum realistic speed
                }
                
                // Add final data point
                addSpeedDataPoint(finalSpeed);
                
                // Return average of the last 5 seconds for more stable result
                const stableSpeed = calculateStableSpeed();
                
                // CAP REMOVED - was: Math.max(0.1, Math.round(Math.max(finalSpeed, stableSpeed) * 10) / 10);
                return Math.max(0.1, Math.max(finalSpeed, stableSpeed));
            }
        }
        
        // Calculate stable speed (average of last 5 seconds)
        function calculateStableSpeed() {
            if (speedData.length < 10) return 0;
            
            const stableData = speedData.slice(-Math.min(speedData.length, 40)); // Last 2 seconds (40 * 50ms)
            const average = stableData.reduce((sum, point) => sum + point.speed, 0) / stableData.length;
            return average;
        }
        
        // Format bytes for display
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
        }
        
        // ENHANCED UPLOAD SPEED TEST WITH LONGER DURATION AND LARGER FILES - CAPS REMOVED
        async function testUploadSpeed() {
            updateProgressCard('upload', 0, 'Testing');
            resetGraph('upload');
            
            let totalSpeed = 0;
            let speedCount = 0;
            const testDuration = uploadTestDuration; // 7 seconds now
            
            // Start real-time graph updates
            let totalBytesUploaded = 0;
            let testStartTime = Date.now();
            lastBytesUpdateTime = testStartTime;
            
            // Update progress text
            const uploadProgressText = document.getElementById('uploadProgressText');
            const uploadTimeRemaining = document.getElementById('uploadTimeRemaining');
            
            // Real-time update interval for the graph - every 50ms
            const updateInterval = setInterval(() => {
                const now = Date.now();
                const elapsed = (now - testStartTime) / 1000;
                const remaining = Math.max(0, (uploadTestDuration/1000) - elapsed);
                
                if (elapsed > 0 && totalBytesUploaded > 0) {
                    const currentSpeed = (totalBytesUploaded * 8) / (elapsed * 1024 * 1024);
                    addSpeedDataPoint(currentSpeed);
                    
                    // Update progress text
                    uploadProgressText.textContent = `Uploaded: ${formatBytes(totalBytesUploaded)}`;
                    uploadTimeRemaining.textContent = `Time remaining: ${remaining.toFixed(1)}s`;
                }
            }, 50);
            
            try {
                // Generate larger test data - 4MB instead of 2MB
                const testData = generateTestData(4 * 1024 * 1024);
                const chunkSize = 128 * 1024; // Increased from 64KB to 128KB
                const totalChunks = Math.ceil(testData.byteLength / chunkSize);
                
                let currentChunk = 0;
                const uploadStartTime = Date.now();
                
                // Upload in multiple phases for better accuracy
                const uploadPromises = [];
                
                // Phase 1: Upload initial chunks
                while (Date.now() - uploadStartTime < testDuration && currentChunk < totalChunks) {
                    const start = currentChunk * chunkSize;
                    const end = Math.min(start + chunkSize, testData.byteLength);
                    const chunk = testData.slice(start, end);
                    
                    const uploadPromise = (async (chunk, chunkNum) => {
                        try {
                            const uploadStart = Date.now();
                            const response = await fetch('https://httpbin.org/post?nocache=' + Date.now() + chunkNum, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/octet-stream',
                                },
                                body: chunk,
                                mode: 'cors'
                            });
                            
                            if (response.ok) {
                                const uploadTime = (Date.now() - uploadStart) / 1000;
                                const chunkSizeBytes = chunk.byteLength;
                                totalBytesUploaded += chunkSizeBytes;
                                
                                if (uploadTime > 0) {
                                    const instantSpeed = (chunkSizeBytes * 8) / (uploadTime * 1024 * 1024);
                                    addSpeedDataPoint(instantSpeed);
                                    totalSpeed += instantSpeed;
                                    speedCount++;
                                    return instantSpeed;
                                }
                            }
                        } catch (error) {
                            // Continue with next chunk
                        }
                        return 0;
                    })(chunk, currentChunk);
                    
                    uploadPromises.push(uploadPromise);
                    currentChunk++;
                    
                    // Small delay to prevent overwhelming the connection
                    if (currentChunk % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                // Phase 2: Upload smaller chunks for more granular measurement
                if (Date.now() - uploadStartTime < testDuration) {
                    const smallChunkSize = 32 * 1024; // 32KB
                    const smallTestData = generateTestData(1 * 1024 * 1024); // 1MB
                    const smallTotalChunks = Math.ceil(smallTestData.byteLength / smallChunkSize);
                    
                    for (let i = 0; i < Math.min(smallTotalChunks, 20); i++) {
                        const start = i * smallChunkSize;
                        const end = Math.min(start + smallChunkSize, smallTestData.byteLength);
                        const chunk = smallTestData.slice(start, end);
                        
                        const smallUploadPromise = (async (chunk, chunkNum) => {
                            try {
                                const uploadStart = Date.now();
                                const response = await fetch('https://httpbin.org/post?small=1&nocache=' + Date.now() + chunkNum, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/octet-stream',
                                    },
                                    body: chunk,
                                    mode: 'cors'
                                });
                                
                                if (response.ok) {
                                    const uploadTime = (Date.now() - uploadStart) / 1000;
                                    const chunkSizeBytes = chunk.byteLength;
                                    totalBytesUploaded += chunkSizeBytes;
                                    
                                    if (uploadTime > 0) {
                                        const instantSpeed = (chunkSizeBytes * 8) / (uploadTime * 1024 * 1024);
                                        addSpeedDataPoint(instantSpeed);
                                        totalSpeed += instantSpeed;
                                        speedCount++;
                                        return instantSpeed;
                                    }
                                }
                            } catch (error) {
                                // Continue with next chunk
                            }
                            return 0;
                        })(chunk, i);
                        
                        uploadPromises.push(smallUploadPromise);
                        
                        if (Date.now() - uploadStartTime >= testDuration) break;
                    }
                }
                
                // Wait for all uploads to complete
                await Promise.all(uploadPromises);
                
            } catch (error) {
                console.log('Upload test error:', error);
            } finally {
                clearInterval(updateInterval);
                uploadProgressText.textContent = '';
                uploadTimeRemaining.textContent = '';
                
                // Calculate final average speed
                const totalElapsed = (Date.now() - testStartTime) / 1000;
                let finalSpeed = 0;
                
                if (totalElapsed > 0 && totalBytesUploaded > 0) {
                    finalSpeed = (totalBytesUploaded * 8) / (totalElapsed * 1024 * 1024);
                } else if (speedCount > 0) {
                    finalSpeed = totalSpeed / speedCount;
                } else {
                    // FALLBACK SPEED CAP REMOVED - was: finalSpeed = 2;
                    finalSpeed = 0.1; // Minimum realistic speed
                }
                
                // Add final data point
                addSpeedDataPoint(finalSpeed);
                
                // Return average of the last 5 seconds for more stable result
                const stableSpeed = calculateStableSpeed();
                
                // CAP REMOVED - was: Math.max(0.1, Math.round(Math.max(finalSpeed, stableSpeed) * 10) / 10);
                return Math.max(0.1, Math.max(finalSpeed, stableSpeed));
            }
        }
        
        // Update speed display
        function updateSpeedDisplay(speed) {
            const speedValue = document.getElementById('speedValue');
            const speedStatus = document.getElementById('speedStatus');
            
            speedValue.className = 'speed-value ';
            speedStatus.className = 'result-status';
            
            if (speed > 500) {
                speedValue.classList.add('speed-ultra');
                speedStatus.textContent = 'Ultra-Fast Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 200) {
                speedValue.classList.add('speed-excellent');
                speedStatus.textContent = 'Excellent Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 100) {
                speedValue.classList.add('speed-excellent');
                speedStatus.textContent = 'Very Fast Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 50) {
                speedValue.classList.add('speed-good');
                speedStatus.textContent = 'Fast Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 25) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Good Connection';
                speedStatus.classList.add('result-status-good');
            } else if (speed > 10) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Fair Connection';
                speedStatus.classList.add('result-status-good');
            } else if (speed > 3) {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Slow Connection';
                speedStatus.classList.add('result-status-slow');
            } else {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Very Slow Connection';
                speedStatus.classList.add('result-status-slow');
            }
            
            speedValue.innerHTML = `${speed.toFixed(1)} <span style="font-size: 0.5em;">Mbps</span>`;
        }
        
        // Scroll to results
        function scrollToResults() {
            const speedResult = document.getElementById('speedResult');
            speedResult.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
        }
        
        // Main speed test function
        async function startSpeedTest() {
            if (testInProgress || !bestServer) return;
            
            const resultDiv = document.getElementById('speedResult');
            const testButton = document.getElementById('testButton');
            
            testInProgress = true;
            testButton.disabled = true;
            testButton.textContent = 'Testing in Progress...';
            resultDiv.style.display = 'none';
            
            hideError();
            
            showProgressContainer();
            
            try {
                // Stage 1: Location
                updateStage('location');
                document.getElementById('testPhase').textContent = 'Connecting to Server...';
                document.getElementById('testPhaseBadge').textContent = 'Connecting';
                document.getElementById('testPhaseBadge').className = 'test-phase-badge testing';
                
                // Already have location from initialization
                updateLocationDisplay(userLocation);
                
                // Stage 2: Download test
                updateStage('download');
                updateProgressCard('download', 0, 'Testing');
                document.getElementById('testPhase').textContent = 'Testing Download Speed (8 seconds)...';
                document.getElementById('testPhaseBadge').textContent = 'Downloading';
                
                const downloadSpeed = await testDownloadSpeed();
                document.getElementById('downloadSpeed').textContent = downloadSpeed.toFixed(1) + ' Mbps';
                document.getElementById('speedValue').textContent = downloadSpeed.toFixed(1);
                
                updateProgressCard('download', downloadSpeed, 'Completed');
                
                // Stage 3: Upload test
                updateStage('upload');
                updateProgressCard('upload', 0, 'Testing');
                document.getElementById('testPhase').textContent = 'Testing Upload Speed (7 seconds)...';
                document.getElementById('testPhaseBadge').textContent = 'Uploading';
                
                const uploadSpeed = await testUploadSpeed();
                document.getElementById('uploadSpeed').textContent = uploadSpeed.toFixed(1) + ' Mbps';
                
                updateProgressCard('upload', uploadSpeed, 'Completed');
                
                // Stage 4: Analysis
                updateStage('complete');
                document.getElementById('testPhase').textContent = 'Analyzing Results...';
                document.getElementById('testPhaseBadge').textContent = 'Analyzing';
                document.getElementById('testPhaseBadge').className = 'test-phase-badge testing';
                
                updateSpeedDisplay(downloadSpeed);
                
                document.getElementById('graphOverlay').style.display = 'none';
                
                setTimeout(() => {
                    hideProgressContainer();
                    resultDiv.style.display = 'block';
                    testButton.disabled = false;
                    testButton.textContent = 'Run New Test';
                    testInProgress = false;
                    document.getElementById('serverSelection').style.display = 'block';
                    scrollToResults();
                }, 1000);
                
            } catch (error) {
                document.getElementById('testPhase').textContent = 'Test Failed';
                document.getElementById('testPhaseBadge').textContent = 'Error';
                document.getElementById('testPhaseBadge').className = 'test-phase-badge';
                console.error('Speed test error:', error);
                
                setTimeout(() => {
                    hideProgressContainer();
                    testButton.disabled = false;
                    testButton.textContent = 'Start Speed Test';
                    testInProgress = false;
                    document.getElementById('serverSelection').style.display = 'block';
                    showError('Speed test failed. Please check your connection and try again.');
                }, 2000);
            }
        }
        
        // Main initialization function
        async function initializeApp() {
            initializationAttempted = true;
            const preloader = document.getElementById('preloader');
            const testButton = document.getElementById('testButton');
            
            updateLoadingProgress(5);
            await new Promise(resolve => setTimeout(resolve, 300));
            
            updateLoadingProgress(15);
            await new Promise(resolve => setTimeout(resolve, 200));
            
            updateLoadingProgress(25);
            
            try {
                userLocation = await detectUserLocation();
                updateLocationDisplay(userLocation);
                
                console.log('Detected location:', userLocation);
                
                updateLoadingProgress(60);
                await findAndTestServerOptions(userLocation);
                
                updateLoadingProgress(100);
                
                setTimeout(() => {
                    preloader.classList.add('hidden');
                }, 500);
                
            } catch (error) {
                console.log('Initialization failed:', error);
                updateLoadingProgress(100);
                
                setTimeout(() => {
                    preloader.classList.add('hidden');
                    showError('Unable to initialize speed test. Using default servers.');
                    
                    bestServer = testServers.find(s => s.id === 'cdn_global') || testServers[0];
                    updateServerDisplay(bestServer);
                    
                    testButton.disabled = false;
                    testButton.textContent = 'Start Speed Test';
                }, 500);
            }
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            checkPermissions();
            initializeApp();
        });
        
        // Initialize on window resize
        window.addEventListener('resize', () => {
            if (document.getElementById('testProgressContainer').style.display === 'block') {
                initializeSpeedGraph();
            }
        });
    </script>
</body>
</html>
