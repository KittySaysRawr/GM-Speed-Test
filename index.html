<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Speed Checker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css">
    <style>
        :root {
            --green-primary: #4CAF50;
            --green-dark: #2E7D32;
            --green-light: #C8E6C9;
            --amber: #FF9800;
            --red: #F44336;
            --text-dark: #333;
            --text-light: #fff;
            --bg-light: #f5f5f5;
            --bg-dark: #263238;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg-light);
            color: var(--text-dark);
            transition: all 0.3s ease;
            min-height: 100vh;
        }
        
        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-light);
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .dark-mode .container {
            background: #37474F;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
        }
        
        .location-info {
            background: var(--green-light);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-size: 0.95em;
        }
        
        .dark-mode .location-info {
            background: #1B5E20;
        }
        
        .location-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        
        .location-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            min-width: 300px;
            justify-content: space-between;
        }
        
        .dark-mode .location-row {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .location-text {
            font-weight: 500;
            flex-grow: 1;
            text-align: left;
        }
        
        .flag-icon {
            width: 24px;
            height: 18px;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .server-map {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .server-pill {
            background: #e0e0e0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        
        .server-pill.testing {
            background: var(--green-primary);
            color: white;
            transform: scale(1.05);
        }
        
        .server-pill.selected {
            background: var(--green-dark);
            color: white;
            font-weight: bold;
        }
        
        .server-pill.failed {
            background: #ffebee;
            color: #c62828;
        }
        
        .dark-mode .server-pill {
            background: #455A64;
        }
        
        .dark-mode .server-pill.testing {
            background: var(--green-primary);
        }
        
        .dark-mode .server-pill.selected {
            background: var(--green-dark);
        }
        
        .speed-result {
            display: none;
            text-align: center;
            padding: 40px 30px;
            margin: 20px 0;
            border-radius: 8px;
            background: var(--green-light);
        }
        
        .dark-mode .speed-result {
            background: #1B5E20;
        }
        
        .speed-value {
            font-size: 3.5em;
            font-weight: bold;
            margin: 10px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .speed-value {
            color: var(--text-light);
        }
        
        .speed-good { color: var(--green-dark); }
        .speed-medium { color: var(--amber); }
        .speed-slow { color: var(--red); }
        
        .test-button {
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            transition: all 0.3s ease;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        
        .test-button:hover:not(:disabled) {
            transform: translateY(-3px);
            background: var(--green-dark);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        .test-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }
        
        .test-details {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .detail-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 10px;
            min-width: 150px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dark-mode .detail-box {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .detail-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
            color: var(--text-dark);
        }
        
        .dark-mode .detail-value {
            color: var(--text-light);
        }
        
        .detail-label {
            font-size: 0.95em;
            color: #666;
            font-weight: 500;
        }
        
        .dark-mode .detail-label {
            color: #ccc;
        }
        
        .progress-container {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            margin: 40px 0 30px 0;
            overflow: hidden;
            display: none;
        }
        
        .dark-mode .progress-container {
            background: #455A64;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--green-primary), var(--green-dark));
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .status-message {
            text-align: center;
            margin: 25px 0;
            font-size: 1.1em;
            color: #666;
            min-height: 28px;
            font-weight: 500;
        }
        
        .dark-mode .status-message {
            color: #ccc;
        }
        
        .test-stages {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            font-size: 0.95em;
            color: #666;
        }
        
        .test-stage {
            text-align: center;
            flex: 1;
            padding: 10px 5px;
            opacity: 0.5;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .test-stage.active {
            color: var(--green-primary);
            font-weight: bold;
            opacity: 1;
            border-bottom: 3px solid var(--green-primary);
        }
        
        .connection-info {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9em;
            color: #666;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
        }
        
        .dark-mode .connection-info {
            background: rgba(0, 0, 0, 0.2);
            color: #ccc;
        }
        
        .server-testing {
            margin-top: 25px;
            padding: 15px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .dark-mode .server-testing {
            background: rgba(46, 125, 50, 0.2);
        }
        
        .jitter-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .accuracy-note {
            text-align: center;
            font-size: 0.85em;
            color: #888;
            margin-top: 20px;
            font-style: italic;
        }
        
        .dark-mode .accuracy-note {
            color: #aaa;
        }
        
        .connection-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .badge-wifi { background: #4CAF50; color: white; }
        .badge-4g { background: #2196F3; color: white; }
        .badge-5g { background: #9C27B0; color: white; }
        .badge-ethernet { background: #795548; color: white; }
        .badge-unknown { background: #9E9E9E; color: white; }
        
        /* Result status text */
        .result-status {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 30px;
            padding: 8px 20px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .result-status-excellent {
            background-color: rgba(46, 125, 50, 0.15);
            color: var(--green-dark);
            border: 2px solid rgba(46, 125, 50, 0.3);
        }
        
        .dark-mode .result-status-excellent {
            background-color: rgba(76, 175, 80, 0.2);
            color: #C8E6C9;
            border: 2px solid rgba(76, 175, 80, 0.4);
        }
        
        .result-status-good {
            background-color: rgba(255, 152, 0, 0.15);
            color: #EF6C00;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }
        
        .dark-mode .result-status-good {
            background-color: rgba(255, 152, 0, 0.2);
            color: #FFE0B2;
            border: 2px solid rgba(255, 152, 0, 0.4);
        }
        
        .result-status-slow {
            background-color: rgba(244, 67, 54, 0.15);
            color: #D32F2F;
            border: 2px solid rgba(244, 67, 54, 0.3);
        }
        
        .dark-mode .result-status-slow {
            background-color: rgba(244, 67, 54, 0.2);
            color: #FFCDD2;
            border: 2px solid rgba(244, 67, 54, 0.4);
        }
        
        /* Simplified Preloader styles */
        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-light);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .dark-mode .preloader {
            background: var(--bg-dark);
        }
        
        .preloader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .preloader-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .loading-text {
            font-size: 1.4em;
            color: var(--text-dark);
            font-weight: 500;
            margin-bottom: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
        }
        
        .dark-mode .loading-text {
            color: var(--text-light);
        }
        
        .spinner-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .spinner {
            width: 120px;
            height: 120px;
            border: 8px solid rgba(76, 175, 80, 0.2);
            border-top: 8px solid var(--green-primary);
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
        }
        
        .spinner-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            font-weight: bold;
            color: var(--green-dark);
            text-align: center;
            line-height: 1;
            width: 100%;
        }
        
        .dark-mode .spinner-percentage {
            color: var(--green-light);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Connection type indicator */
        .connection-type-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
            font-size: 0.85em;
            color: #666;
        }
        
        .dark-mode .connection-type-indicator {
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="preloader" id="preloader">
        <div class="preloader-content">
            <div class="loading-text" id="loadingText">Powering up the hamsters...</div>
            <div class="spinner-container">
                <div class="spinner"></div>
                <div class="spinner-percentage" id="loadingPercentage">0%</div>
            </div>
        </div>
    </div>
    
    <button class="theme-toggle" onclick="toggleTheme()">Toggle Light/Dark</button>
    
    <div class="container">
        <div class="header">
            <h1>Internet Speed Checker</h1>
            <p>Test your internet connection speed</p>
        </div>
        
        <div class="location-info" id="locationInfo">
            <div class="location-display">
                <div class="location-row">
                    <span class="location-text" id="userLocation">Detecting your location...</span>
                    <span class="flag-icon" id="userFlag"></span>
                </div>
                <div class="location-row">
                    <span class="location-text" id="testServer">Finding best test server...</span>
                    <span class="flag-icon" id="serverFlag"></span>
                </div>
            </div>
        </div>
        
        <div class="server-map" id="serverMap" style="display: none;">
            <!-- Server pills will be added here dynamically -->
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="test-stages" id="testStages">
            <div class="test-stage" id="stageLocation">Finding Nearest Server</div>
            <div class="test-stage" id="stagePing">Latency Test</div>
            <div class="test-stage" id="stageDownload">Download Test</div>
            <div class="test-stage" id="stageUpload">Upload Test</div>
            <div class="test-stage" id="stageComplete">Analysis</div>
        </div>
        
        <div class="status-message" id="statusMessage">
            Ready to start speed test
        </div>
        
        <button class="test-button" onclick="startSpeedTest()" id="testButton">Start Speed Test</button>
        
        <div id="speedResult" class="speed-result">
            <h2>Connection Analysis Results</h2>
            <div id="speedValue" class="speed-value">--</div>
            <div id="speedStatus" class="result-status">--</div>
            
            <div class="test-details">
                <div class="detail-box">
                    <div class="detail-value" id="downloadSpeed">--</div>
                    <div class="detail-label">DOWNLOAD SPEED</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="downloadQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="uploadSpeed">--</div>
                    <div class="detail-label">UPLOAD SPEED</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="uploadQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="pingValue">--</div>
                    <div class="detail-label">PING</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="pingQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="jitterValue">--</div>
                    <div class="detail-label">JITTER</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="jitterQuality">--</div>
                </div>
            </div>
            
            <div class="connection-info">
                <div id="ispInfo"><strong>ISP:</strong> --</div>
                <div id="connectionType" style="margin-top: 8px;"><strong>Connection Type:</strong> --</div>
                <div id="networkType" style="margin-top: 8px;"><strong>Network Technology:</strong> --</div>
                <div id="detectedLocation" style="margin-top: 8px;"><strong>Your Location:</strong> --</div>
                <div id="connectionAccuracy" style="margin-top: 8px; font-size: 0.85em; color: #666;">
                    <strong>Detection Confidence:</strong> Speed-based analysis combined with browser API
                </div>
            </div>
            
            <div class="accuracy-note">
                Network type detected based on speed, latency, and browser capabilities
            </div>
        </div>
        
        <div class="server-testing" id="serverTesting" style="display: none;">
            <div id="serverStatus"><strong>Server Selection:</strong> Testing servers by proximity...</div>
            <div id="serverPing" style="margin-top: 5px;"></div>
        </div>
    </div>

    <script>
        // Theme toggle
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }
        
        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
        
        // Whimsical loading messages based on progress
        const loadingMessages = [
            "Powering up the hamsters...",
            "Spinning up the hamster wheel...",
            "Feeding the hamsters their energy snacks...",
            "Tuning the hamster antennas...",
            "Plotting the optimal hamster route...",
            "Hamsters are warming up their tiny legs...",
            "Coordinating hamster relay teams...",
            "Final hamster preparations...",
            "Almost there! Hamsters at the ready...",
            "Ready to roll!"
        ];
        
        // Location cache
        const LOCATION_CACHE_KEY = 'speedtest_location_cache';
        const LOCATION_CACHE_TTL = 30 * 60 * 1000;
        
        let testInProgress = false;
        let userLocation = null;
        let bestServer = null;
        let detectedConnectionType = 'Unknown';
        let detectedNetworkTech = 'Unknown';
        let loadingProgress = 0;
        
        // Country code to flag mapping
        const countryFlagMap = {
            'GB': 'gb', 'UK': 'gb', 'US': 'us', 'DE': 'de', 'JP': 'jp',
            'FR': 'fr', 'CA': 'ca', 'AU': 'au', 'BR': 'br', 'IN': 'in',
            'CN': 'cn', 'RU': 'ru', 'IT': 'it', 'ES': 'es', 'NL': 'nl',
            'SE': 'se', 'NO': 'no', 'DK': 'dk', 'FI': 'fi', 'PL': 'pl'
        };
        
        // Get flag class for country code
        function getFlagClass(countryCode) {
            const code = (countryCode || 'unknown').toUpperCase();
            if (countryFlagMap[code]) {
                return `flag-icon-${countryFlagMap[code]}`;
            }
            return 'flag-icon-us'; // Default to US flag
        }
        
        // Server database
        const testServers = [
            { 
                id: 'cdn1', 
                name: "Global CDN Network", 
                pingUrl: "https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js",
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=10000000",
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                countryCode: "GL",
                city: "CDN Edge",
                lat: null,
                lon: null,
            },
            { 
                id: 'github', 
                name: "GitHub USA Server", 
                pingUrl: "https://raw.githubusercontent.com/git/git/master/README.md",
                downloadUrl: "https://raw.githubusercontent.com/torvalds/linux/master/README",
                uploadUrl: "https://httpbin.org/post",
                country: "United States",
                countryCode: "US",
                city: "San Francisco",
                lat: 37.7749,
                lon: -122.4194,
            },
            { 
                id: 'cloudflare', 
                name: "Cloudflare Global", 
                pingUrl: "https://1.1.1.1/cdn-cgi/trace",
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=5000000",
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                countryCode: "GL",
                city: "Anycast Network",
                lat: null,
                lon: null,
            },
            { 
                id: 'jsdelivr', 
                name: "jsDelivr CDN", 
                pingUrl: "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js",
                downloadUrl: "https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                countryCode: "GL",
                city: "CDN Network",
                lat: null,
                lon: null,
            }
        ];
        
        // Update loading progress with whimsical messages
        function updateLoadingProgress(progress) {
            loadingProgress = Math.min(100, Math.max(0, progress));
            const percentageEl = document.getElementById('loadingPercentage');
            const loadingTextEl = document.getElementById('loadingText');
            
            percentageEl.textContent = `${Math.round(loadingProgress)}%`;
            
            // Update loading message based on progress
            const messageIndex = Math.min(
                Math.floor(loadingProgress / 10),
                loadingMessages.length - 1
            );
            loadingTextEl.textContent = loadingMessages[messageIndex];
            
            const spinner = document.querySelector('.spinner');
            if (loadingProgress < 30) {
                spinner.style.borderTopColor = '#FF9800';
            } else if (loadingProgress < 70) {
                spinner.style.borderTopColor = '#2196F3';
            } else {
                spinner.style.borderTopColor = '#4CAF50';
            }
        }
        
        // Haversine formula for distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Get cached location
        function getCachedLocation() {
            try {
                const cached = localStorage.getItem(LOCATION_CACHE_KEY);
                if (!cached) return null;
                
                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();
                
                if (now - timestamp < LOCATION_CACHE_TTL) {
                    return data;
                }
                
                localStorage.removeItem(LOCATION_CACHE_KEY);
                return null;
            } catch (error) {
                return null;
            }
        }
        
        // Cache location data
        function cacheLocationData(locationData) {
            try {
                const cacheData = {
                    data: locationData,
                    timestamp: Date.now()
                };
                localStorage.setItem(LOCATION_CACHE_KEY, JSON.stringify(cacheData));
            } catch (error) {
                // Ignore caching errors
            }
        }
        
        // IMPROVED: Try to get precise location from browser GPS
        async function getPreciseLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve(null);
                    return;
                }
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            source: 'gps'
                        });
                    },
                    (error) => {
                        // User denied or error getting GPS location
                        resolve(null);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );
            });
        }
        
        // IMPROVED: More accurate location detection
        async function detectUserLocation() {
            updateLoadingProgress(40);
            
            // Check cache first
            const cached = getCachedLocation();
            if (cached) {
                updateLoadingProgress(50);
                await new Promise(resolve => setTimeout(resolve, 300));
                return cached;
            }
            
            let locationData = {
                country: 'Unknown',
                city: 'Unknown',
                region: 'Unknown',
                latitude: null,
                longitude: null,
                isp: 'Unknown',
                method: 'unknown',
                countryCode: 'Unknown',
                accuracy: 'low'
            };
            
            // Try multiple location sources in order of accuracy
            
            // 1. First try browser GPS for most accurate location
            try {
                updateLoadingProgress(45);
                const preciseLocation = await getPreciseLocation();
                if (preciseLocation) {
                    locationData.latitude = preciseLocation.latitude;
                    locationData.longitude = preciseLocation.longitude;
                    locationData.accuracy = 'high';
                    locationData.method = 'gps';
                    
                    // Try to reverse geocode GPS coordinates for city/country
                    try {
                        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${preciseLocation.latitude}&lon=${preciseLocation.longitude}&zoom=10`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.address) {
                                locationData.city = data.address.city || data.address.town || data.address.village || data.address.municipality || 'Unknown';
                                locationData.country = data.address.country || 'Unknown';
                                locationData.countryCode = data.address.country_code?.toUpperCase() || 'Unknown';
                                locationData.region = data.address.state || data.address.region || 'Unknown';
                            }
                        }
                    } catch (error) {
                        // Continue with IP-based location
                    }
                }
            } catch (error) {
                // GPS failed, continue with IP-based detection
            }
            
            // 2. If no GPS or couldn't reverse geocode, try IP-based location
            if (!locationData.city || locationData.city === 'Unknown') {
                try {
                    updateLoadingProgress(55);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    
                    // Try ipapi.co first
                    const response = await fetch('https://ipapi.co/json/', {
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        updateLoadingProgress(65);
                        const data = await response.json();
                        
                        // Only update if we don't have better data
                        if (!locationData.city || locationData.city === 'Unknown') {
                            locationData.city = data.city || 'Unknown';
                        }
                        if (!locationData.country || locationData.country === 'Unknown') {
                            locationData.country = data.country_name || 'Unknown';
                        }
                        if (!locationData.countryCode || locationData.countryCode === 'Unknown') {
                            locationData.countryCode = data.country_code || 'Unknown';
                        }
                        if (!locationData.region || locationData.region === 'Unknown') {
                            locationData.region = data.region || 'Unknown';
                        }
                        if (!locationData.latitude) {
                            locationData.latitude = data.latitude;
                        }
                        if (!locationData.longitude) {
                            locationData.longitude = data.longitude;
                        }
                        locationData.isp = data.org || data.asn || 'Unknown ISP';
                        locationData.method = locationData.method === 'gps' ? 'gps+ip' : 'ip_geolocation';
                    }
                } catch (error) {
                    // Try alternative IP service
                    try {
                        const backupResponse = await fetch('https://ipinfo.io/json?token=free', {
                            signal: AbortSignal.timeout(3000)
                        });
                        
                        if (backupResponse.ok) {
                            const data = await backupResponse.json();
                            const [lat, lon] = data.loc ? data.loc.split(',').map(Number) : [null, null];
                            
                            if (!locationData.city || locationData.city === 'Unknown') {
                                locationData.city = data.city || 'Unknown';
                            }
                            if (!locationData.country || locationData.country === 'Unknown') {
                                locationData.country = data.country || 'Unknown';
                            }
                            if (!locationData.countryCode || locationData.countryCode === 'Unknown') {
                                locationData.countryCode = data.country || 'Unknown';
                            }
                            if (!locationData.region || locationData.region === 'Unknown') {
                                locationData.region = data.region || 'Unknown';
                            }
                            if (!locationData.latitude) {
                                locationData.latitude = lat;
                            }
                            if (!locationData.longitude) {
                                locationData.longitude = lon;
                            }
                            locationData.isp = data.org || data.hostname || 'Unknown ISP';
                            locationData.method = locationData.method === 'gps' ? 'gps+ip' : 'ipinfo_io';
                        }
                    } catch (backupError) {
                        // Fallback to browser detection
                        updateLoadingProgress(60);
                        const browserLanguage = navigator.language || 'en-US';
                        const countryCode = browserLanguage.split('-')[1] || 'US';
                        locationData.countryCode = countryCode;
                        locationData.method = 'browser_language';
                    }
                }
            }
            
            // 3. Final fallback if still no location
            if (locationData.city === 'Unknown' && locationData.country === 'Unknown') {
                locationData.country = 'Detected from browser';
                locationData.method = 'browser_detection';
            }
            
            updateLoadingProgress(70);
            cacheLocationData(locationData);
            
            return locationData;
        }
        
        async function findBestServer(userLocation) {
            updateLoadingProgress(75);
            
            let candidates = [];
            
            if (userLocation.latitude && userLocation.longitude) {
                const serversWithCoords = testServers.filter(s => s.lat && s.lon);
                serversWithCoords.forEach(server => {
                    const distance = calculateDistance(
                        userLocation.latitude,
                        userLocation.longitude,
                        server.lat,
                        server.lon
                    );
                    
                    candidates.push({
                        server: server,
                        distance: distance
                    });
                });
                
                candidates.sort((a, b) => a.distance - b.distance);
            } else {
                candidates = testServers.map(server => ({ server, distance: null }));
            }
            
            let bestServer = null;
            let bestPing = Infinity;
            
            for (let i = 0; i < Math.min(3, candidates.length); i++) {
                const candidate = candidates[i];
                updateLoadingProgress(80 + (i * 5));
                
                try {
                    const ping = await testServerPing(candidate.server.pingUrl);
                    
                    if (ping < bestPing) {
                        bestPing = ping;
                        bestServer = candidate.server;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                } catch (error) {
                    continue;
                }
            }
            
            updateLoadingProgress(95);
            
            return bestServer || candidates[0]?.server || testServers[0];
        }
        
        // Update location display with flags
        function updateLocationDisplay(location, server) {
            const userLocationEl = document.getElementById('userLocation');
            const testServerEl = document.getElementById('testServer');
            const userFlagEl = document.getElementById('userFlag');
            const serverFlagEl = document.getElementById('serverFlag');
            const statusMessage = document.getElementById('statusMessage');
            
            // Update user location with more specific info
            let locationText = 'Your Location: ';
            if (location.city !== 'Unknown' && location.region !== 'Unknown' && location.country !== 'Unknown') {
                locationText += `${location.city}, ${location.region}, ${location.country}`;
            } else if (location.city !== 'Unknown' && location.country !== 'Unknown') {
                locationText += `${location.city}, ${location.country}`;
            } else if (location.country !== 'Unknown') {
                locationText += location.country;
            } else {
                locationText += 'Location detected from connection data';
            }
            userLocationEl.textContent = locationText;
            
            // Update user flag
            if (location.countryCode && location.countryCode !== 'Unknown') {
                userFlagEl.className = `flag-icon ${getFlagClass(location.countryCode)}`;
                userFlagEl.style.display = 'inline-block';
            } else {
                userFlagEl.style.display = 'none';
            }
            
            // Update test server
            let serverText = 'Test Server: ';
            if (server.country === 'Global') {
                serverText += 'Global CDN Network';
            } else {
                serverText += `${server.city}, ${server.country}`;
            }
            testServerEl.textContent = serverText;
            
            // Update server flag
            if (server.countryCode && server.countryCode !== 'GL') {
                serverFlagEl.className = `flag-icon ${getFlagClass(server.countryCode)}`;
                serverFlagEl.style.display = 'inline-block';
            } else {
                serverFlagEl.className = 'flag-icon flag-icon-globe';
                serverFlagEl.style.display = 'inline-block';
            }
            
            // Update status message with connection info
            if ('connection' in navigator) {
                const conn = navigator.connection;
                let info = 'Ready to start speed test';
                
                if (conn.effectiveType) {
                    info = `Connection: ${conn.effectiveType.toUpperCase()}`;
                    if (conn.downlink) {
                        info += ` (${conn.downlink} Mbps estimated)`;
                    }
                }
                statusMessage.textContent = info;
            }
        }
        
        // IMPROVED: Better 5G detection
        async function detectConnectionType(downloadSpeed, uploadSpeed, ping, jitter) {
            let connectionInfo = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            // First check browser API
            const browserDetection = detectConnectionFromBrowser();
            if (browserDetection.type !== 'Unknown') {
                connectionInfo = browserDetection;
                connectionInfo.details.push('Detected via browser API');
                connectionInfo.confidence = 70;
            }
            
            // Then analyze speed patterns with IMPROVED 5G detection
            const speedDetection = detectConnectionFromSpeed(downloadSpeed, uploadSpeed, ping, jitter);
            
            // IMPORTANT: If speed detection suggests 5G, prioritize it over browser detection
            // Browser often mislabels 5G as 4G
            if (speedDetection.technology === '5G') {
                connectionInfo = speedDetection;
                connectionInfo.details.push('Speed analysis indicates 5G (browser may mislabel as 4G)');
                connectionInfo.confidence = Math.max(connectionInfo.confidence, 85);
            } else if (speedDetection.confidence > connectionInfo.confidence || connectionInfo.type === 'Unknown') {
                connectionInfo = speedDetection;
                connectionInfo.details.push('Detected via speed analysis');
            }
            
            // Special 5G detection for high speeds
            if (downloadSpeed > 200 && ping < 30 && jitter < 15) {
                // Ultra-fast speeds with low latency = very likely 5G
                connectionInfo.technology = '5G';
                connectionInfo.type = 'Mobile';
                connectionInfo.confidence = 95;
                connectionInfo.details.push('Ultra-high speed with low latency indicates 5G');
            } else if (downloadSpeed > 100 && uploadSpeed > 20 && ping < 40 && jitter < 20) {
                // High speeds with good upload = likely 5G
                connectionInfo.technology = '5G';
                connectionInfo.type = 'Mobile';
                connectionInfo.confidence = 85;
                connectionInfo.details.push('High symmetrical speeds indicate 5G');
            }
            
            // Clean up connection type display
            if (connectionInfo.technology === '5G' || connectionInfo.technology === '4G/LTE' || connectionInfo.technology === '3G') {
                connectionInfo.type = 'Mobile';
            } else if (connectionInfo.technology === 'WiFi') {
                connectionInfo.type = 'WiFi';
            } else if (connectionInfo.technology === 'Fiber' || connectionInfo.technology === 'Cable' || connectionInfo.technology === 'DSL') {
                connectionInfo.type = 'Wired';
            } else if (connectionInfo.technology === 'Satellite') {
                connectionInfo.type = 'Satellite';
            }
            
            return connectionInfo;
        }
        
        function detectConnectionFromBrowser() {
            const info = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            if (!('connection' in navigator)) {
                info.details.push('No browser connection API available');
                return info;
            }
            
            const conn = navigator.connection;
            
            if (conn.type) {
                info.type = conn.type;
                info.confidence = 60;
                info.details.push(`Browser reports type: ${conn.type}`);
            }
            
            if (conn.effectiveType) {
                // Browser often reports 5G as "4g" - we'll override this later based on speed
                info.technology = conn.effectiveType.toUpperCase();
                info.confidence = Math.max(info.confidence, 50);
                info.details.push(`Browser reports effective type: ${conn.effectiveType}`);
                
                // Map to our technology names
                if (conn.effectiveType.includes('4g')) {
                    info.technology = '4G/LTE';
                } else if (conn.effectiveType.includes('3g')) {
                    info.technology = '3G';
                } else if (conn.effectiveType.includes('2g')) {
                    info.technology = '2G';
                }
            }
            
            if (conn.downlink) {
                info.details.push(`Estimated downlink: ${conn.downlink} Mbps`);
            }
            
            if (conn.type === 'cellular' || conn.effectiveType) {
                info.type = 'Mobile';
            }
            
            if (conn.type === 'wifi' || conn.type === 'wimax') {
                info.type = 'WiFi';
                info.technology = 'WiFi';
            }
            
            if (conn.type === 'ethernet') {
                info.type = 'Wired';
                info.technology = 'Ethernet';
            }
            
            return info;
        }
        
        function detectConnectionFromSpeed(downloadSpeed, uploadSpeed, ping, jitter) {
            const info = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            let bestMatch = null;
            let bestScore = 0;
            
            const networkTypePatterns = {
                '5G': {
                    minDownload: 100,
                    maxDownload: 3000,
                    minUpload: 10,
                    maxUpload: 200,
                    maxPing: 40,
                    maxJitter: 15,
                    scoreMultiplier: 1.2 // Give 5G extra weight
                },
                '4G/LTE': {
                    minDownload: 10,
                    maxDownload: 150,
                    minUpload: 2,
                    maxUpload: 50,
                    maxPing: 80,
                    maxJitter: 25,
                    scoreMultiplier: 1.0
                },
                'Fiber': {
                    minDownload: 50,
                    maxDownload: 2000,
                    minUpload: 50,
                    maxUpload: 2000,
                    maxPing: 30,
                    maxJitter: 10,
                    scoreMultiplier: 1.1
                },
                'Cable': {
                    minDownload: 25,
                    maxDownload: 500,
                    minUpload: 5,
                    maxUpload: 50,
                    maxPing: 40,
                    maxJitter: 15,
                    scoreMultiplier: 1.0
                },
                'DSL': {
                    minDownload: 5,
                    maxDownload: 100,
                    minUpload: 1,
                    maxUpload: 20,
                    maxPing: 60,
                    maxJitter: 25,
                    scoreMultiplier: 1.0
                },
                'WiFi': {
                    minDownload: 10,
                    maxDownload: 500,
                    minUpload: 5,
                    maxUpload: 100,
                    maxPing: 50,
                    maxJitter: 30,
                    scoreMultiplier: 1.0
                },
                'Satellite': {
                    minDownload: 5,
                    maxDownload: 100,
                    minUpload: 1,
                    maxUpload: 20,
                    minPing: 500,
                    maxPing: 2000,
                    maxJitter: 100,
                    scoreMultiplier: 1.0
                }
            };
            
            for (const [tech, pattern] of Object.entries(networkTypePatterns)) {
                let score = 0;
                
                // Download speed match
                if (downloadSpeed >= pattern.minDownload && downloadSpeed <= pattern.maxDownload) {
                    score += 30;
                } else if (downloadSpeed > pattern.maxDownload && tech !== '5G') {
                    // Very high speeds suggest 5G or Fiber
                    score += 15;
                } else if (downloadSpeed < pattern.minDownload) {
                    score += 5;
                }
                
                // Upload speed match
                if (uploadSpeed >= pattern.minUpload && uploadSpeed <= pattern.maxUpload) {
                    score += 20;
                }
                
                // Ping/latency match
                if (tech === 'Satellite') {
                    if (ping >= pattern.minPing && ping <= pattern.maxPing) {
                        score += 40; // High weight for satellite's characteristic high latency
                    }
                } else if (ping <= pattern.maxPing) {
                    score += 25;
                }
                
                // Jitter match
                if (jitter <= pattern.maxJitter) {
                    score += 15;
                }
                
                // Special characteristics
                if (tech === 'Fiber') {
                    const ratio = uploadSpeed / downloadSpeed;
                    if (ratio > 0.3 && ratio < 3) {
                        score += 25; // High weight for symmetrical speeds (fiber characteristic)
                    }
                }
                
                if (tech === '5G' && downloadSpeed > 200 && ping < 30) {
                    score += 30; // Bonus for ultra-fast 5G characteristics
                }
                
                // Apply multiplier
                score *= pattern.scoreMultiplier;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = tech;
                }
            }
            
            if (bestMatch && bestScore > 40) {
                info.technology = bestMatch;
                info.confidence = Math.min(95, bestScore);
                info.details.push(`Matched ${bestMatch} pattern with score ${Math.round(bestScore)}`);
                
                // Map technology to type
                if (bestMatch === '5G' || bestMatch === '4G/LTE' || bestMatch === '3G') {
                    info.type = 'Mobile';
                } else if (bestMatch === 'WiFi') {
                    info.type = 'WiFi';
                } else if (bestMatch === 'Fiber' || bestMatch === 'Cable' || bestMatch === 'DSL') {
                    info.type = 'Wired';
                } else if (bestMatch === 'Satellite') {
                    info.type = 'Satellite';
                }
            }
            
            return info;
        }
        
        // Rest of the functions remain similar but updated for new location display
        async function testServerPing(pingUrl) {
            let pings = [];
            
            for (let i = 0; i < 4; i++) {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    
                    await fetch(pingUrl, {
                        signal: controller.signal,
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const ping = endTime - startTime;
                    
                    if (ping > 1 && ping < 2000) {
                        pings.push(ping);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                } catch (error) {
                    pings.push(100);
                }
            }
            
            if (pings.length === 0) return 100;
            
            pings.sort((a, b) => a - b);
            return pings[Math.floor(pings.length / 2)];
        }
        
        async function testDownloadSpeed() {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Testing download speed...';
            
            let speeds = [];
            const testDuration = 4000;
            const parallelConnections = 4;
            
            const downloadServers = [
                { url: "https://speed.cloudflare.com/__down?bytes=10000000", size: 10000000 },
                { url: "https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js", size: 89513 },
                { url: "https://raw.githubusercontent.com/torvalds/linux/master/README", size: 37000 },
            ];
            
            for (const server of downloadServers) {
                try {
                    const speed = await measureDownloadSpeed(server.url, server.size, testDuration, parallelConnections);
                    
                    if (speed > 0.1 && speed < 5000) {
                        speeds.push(speed);
                    }
                    
                    if (speeds.length >= 2) break;
                    
                } catch (error) {
                    continue;
                }
            }
            
            if (speeds.length === 0) {
                return await simpleDownloadTest();
            }
            
            const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            return Math.round(averageSpeed * 10) / 10;
        }
        
        async function measureDownloadSpeed(url, fileSize, duration, connections) {
            const startTime = performance.now();
            let totalBytes = 0;
            
            return new Promise((resolve, reject) => {
                const connectionPromises = [];
                
                for (let i = 0; i < connections; i++) {
                    connectionPromises.push(
                        fetch(url + `?nocache=${Date.now()}-${i}`, {
                            cache: 'no-store',
                            headers: {
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            }
                        }).then(async response => {
                            const reader = response.body.getReader();
                            let bytesReceived = 0;
                            
                            while (performance.now() - startTime < duration) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                bytesReceived += value.length;
                                totalBytes += value.length;
                            }
                            
                            reader.cancel();
                            return bytesReceived;
                        }).catch(error => {
                            return 0;
                        })
                    );
                }
                
                const progressInterval = setInterval(() => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed >= duration) {
                        clearInterval(progressInterval);
                        const speedMbps = (totalBytes * 8) / (duration / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                    }
                }, 100);
                
                setTimeout(() => {
                    clearInterval(progressInterval);
                    const elapsed = performance.now() - startTime;
                    const speedMbps = (totalBytes * 8) / (elapsed / 1000) / (1024 * 1024);
                    resolve(speedMbps);
                }, duration + 1000);
            });
        }
        
        async function simpleDownloadTest() {
            try {
                const startTime = performance.now();
                const response = await fetch('https://speed.cloudflare.com/__down?bytes=5000000' + `?t=${Date.now()}`, {
                    cache: 'no-store'
                });
                const blob = await response.blob();
                const endTime = performance.now();
                
                const duration = (endTime - startTime) / 1000;
                const speedMbps = (blob.size * 8) / (1024 * 1024) / duration;
                
                return Math.max(0.1, speedMbps);
            } catch (error) {
                return 10;
            }
        }
        
        async function testUploadSpeed() {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Testing upload speed...';
            
            let speeds = [];
            const testDuration = 4000;
            
            const testData = generateTestData(1024 * 1024);
            
            const uploadEndpoints = [
                'https://httpbin.org/post',
                'https://ptsv2.com/t/test/post'
            ];
            
            for (const endpoint of uploadEndpoints) {
                try {
                    const speed = await measureUploadSpeed(endpoint, testData, testDuration);
                    
                    if (speed > 0.1 && speed < 1000) {
                        speeds.push(speed);
                    }
                    
                    if (speeds.length >= 2) break;
                    
                } catch (error) {
                    continue;
                }
            }
            
            if (speeds.length === 0) {
                return await simpleUploadTest();
            }
            
            const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            return Math.round(averageSpeed * 10) / 10;
        }
        
        function generateTestData(size) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < size; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        async function measureUploadSpeed(endpoint, testData, duration) {
            const startTime = performance.now();
            let totalBytesSent = 0;
            
            return new Promise((resolve, reject) => {
                const sendChunk = async () => {
                    if (performance.now() - startTime >= duration) {
                        const elapsed = performance.now() - startTime;
                        const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                        return;
                    }
                    
                    try {
                        const chunkSize = Math.min(50000, testData.length);
                        const chunk = testData.substring(0, chunkSize);
                        
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'text/plain',
                                'Content-Length': chunk.length.toString()
                            },
                            body: chunk,
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            totalBytesSent += chunk.length;
                            setTimeout(sendChunk, 0);
                        } else {
                            const elapsed = performance.now() - startTime;
                            const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                            resolve(speedMbps);
                        }
                    } catch (error) {
                        const elapsed = performance.now() - startTime;
                        const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                    }
                };
                
                sendChunk();
                
                setTimeout(() => {
                    const elapsed = performance.now() - startTime;
                    const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                    resolve(speedMbps);
                }, duration + 1000);
            });
        }
        
        async function simpleUploadTest() {
            try {
                const testData = generateTestData(500 * 1024);
                
                const startTime = performance.now();
                const response = await fetch('https://httpbin.org/post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain',
                    },
                    body: testData
                });
                
                await response.json();
                const endTime = performance.now();
                
                const duration = (endTime - startTime) / 1000;
                const speedMbps = (testData.length * 8) / (1024 * 1024) / duration;
                
                return Math.max(0.1, speedMbps);
                
            } catch (error) {
                return 2;
            }
        }
        
        async function performLatencyTest() {
            let pings = [];
            let jitterSamples = [];
            
            statusMessage.textContent = 'Measuring latency and jitter...';
            
            for (let i = 0; i < 8; i++) {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    await fetch(bestServer.pingUrl + `?size=100&t=${Date.now()}-${i}`, {
                        signal: controller.signal,
                        cache: 'no-store',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const ping = endTime - startTime;
                    
                    if (ping > 1 && ping < 2000) {
                        pings.push(ping);
                        
                        if (pings.length > 1) {
                            const jitter = Math.abs(pings[pings.length - 1] - pings[pings.length - 2]);
                            jitterSamples.push(jitter);
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                } catch (error) {
                    pings.push(50);
                }
            }
            
            if (pings.length === 0) {
                return { ping: 50, jitter: 5 };
            }
            
            pings.sort((a, b) => a - b);
            const medianPing = pings[Math.floor(pings.length / 2)];
            
            let jitter = 1;
            if (jitterSamples.length > 0) {
                jitter = jitterSamples.reduce((a, b) => a + b, 0) / jitterSamples.length;
            }
            
            return {
                ping: Math.round(medianPing),
                jitter: Math.round(jitter * 10) / 10
            };
        }
        
        function getConnectionBadge(type, tech) {
            let badgeClass = 'badge-unknown';
            let badgeText = tech || type;
            
            if (tech === '5G') {
                badgeClass = 'badge-5g';
                badgeText = '5G';
            } else if (tech === '4G/LTE' || tech === '4G') {
                badgeClass = 'badge-4g';
                badgeText = '4G/LTE';
            } else if (type === 'WiFi' || tech === 'WiFi') {
                badgeClass = 'badge-wifi';
                badgeText = 'WiFi';
            } else if (tech === 'Ethernet' || type === 'Wired') {
                badgeClass = 'badge-ethernet';
                badgeText = 'Ethernet';
            } else if (tech === '3G') {
                badgeClass = 'badge-4g';
                badgeText = '3G';
            }
            
            return `<span class="connection-badge ${badgeClass}">${badgeText}</span>`;
        }
        
        function updateSpeedDisplay(speed) {
            const speedValue = document.getElementById('speedValue');
            const speedStatus = document.getElementById('speedStatus');
            
            speedValue.className = 'speed-value ';
            speedStatus.className = 'result-status';
            
            if (speed > 100) {
                speedValue.classList.add('speed-good');
                speedStatus.textContent = 'Excellent Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 50) {
                speedValue.classList.add('speed-good');
                speedStatus.textContent = 'Very Good Connection';
                speedStatus.classList.add('result-status-excellent');
            } else if (speed > 25) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Good Connection';
                speedStatus.classList.add('result-status-good');
            } else if (speed > 10) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Fair Connection';
                speedStatus.classList.add('result-status-good');
            } else if (speed > 3) {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Slow Connection';
                speedStatus.classList.add('result-status-slow');
            } else {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Very Slow Connection';
                speedStatus.classList.add('result-status-slow');
            }
            
            speedValue.innerHTML = `${speed.toFixed(1)} <span style="font-size: 0.5em;">Mbps</span>`;
        }
        
        function updateQualityIndicators(results) {
            const pingQuality = document.getElementById('pingQuality');
            if (results.ping < 30) {
                pingQuality.textContent = 'Excellent';
                pingQuality.style.color = '#2E7D32';
            } else if (results.ping < 60) {
                pingQuality.textContent = 'Good';
                pingQuality.style.color = '#FF9800';
            } else if (results.ping < 100) {
                pingQuality.textContent = 'Fair';
                pingQuality.style.color = '#FF9800';
            } else {
                pingQuality.textContent = 'Poor';
                pingQuality.style.color = '#F44336';
            }
            
            const jitterQuality = document.getElementById('jitterQuality');
            if (results.jitter < 5) {
                jitterQuality.textContent = 'Excellent';
                jitterQuality.style.color = '#2E7D32';
            } else if (results.jitter < 10) {
                jitterQuality.textContent = 'Good';
                jitterQuality.style.color = '#FF9800';
            } else if (results.jitter < 20) {
                jitterQuality.textContent = 'Fair';
                jitterQuality.style.color = '#FF9800';
            } else {
                jitterQuality.textContent = 'Poor';
                jitterQuality.style.color = '#F44336';
            }
        }
        
        function updateStage(stageId) {
            document.querySelectorAll('.test-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            document.getElementById(stageId).classList.add('active');
        }
        
        async function startSpeedTest() {
            if (testInProgress) return;
            
            const resultDiv = document.getElementById('speedResult');
            const testButton = document.getElementById('testButton');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const statusMessage = document.getElementById('statusMessage');
            const serverTesting = document.getElementById('serverTesting');
            
            testInProgress = true;
            testButton.disabled = true;
            testButton.textContent = 'Testing in Progress...';
            resultDiv.style.display = 'none';
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            serverTesting.style.display = 'block';
            
            document.querySelectorAll('.test-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            
            try {
                updateStage('stageLocation');
                statusMessage.textContent = 'Detecting your location and finding nearest server...';
                progressBar.style.width = '10%';
                
                if (!userLocation) {
                    userLocation = await detectUserLocation();
                }
                
                if (!bestServer) {
                    bestServer = await findBestServer(userLocation);
                }
                
                // Update location display
                updateLocationDisplay(userLocation, bestServer);
                
                // Update results display with accurate location
                let detailedLocation = '';
                if (userLocation.city !== 'Unknown' && userLocation.region !== 'Unknown' && userLocation.country !== 'Unknown') {
                    detailedLocation = `${userLocation.city}, ${userLocation.region}, ${userLocation.country}`;
                } else if (userLocation.city !== 'Unknown' && userLocation.country !== 'Unknown') {
                    detailedLocation = `${userLocation.city}, ${userLocation.country}`;
                } else if (userLocation.country !== 'Unknown') {
                    detailedLocation = userLocation.country;
                } else {
                    detailedLocation = 'Detected from connection data';
                }
                
                document.getElementById('detectedLocation').innerHTML = 
                    `<strong>Your Location:</strong> ${detailedLocation}`;
                
                if (userLocation.isp !== 'Unknown' && userLocation.isp !== 'Unknown ISP') {
                    document.getElementById('ispInfo').innerHTML = `<strong>ISP:</strong> ${userLocation.isp}`;
                }
                
                updateStage('stagePing');
                statusMessage.textContent = 'Measuring connection quality...';
                progressBar.style.width = '25%';
                
                const latencyResults = await performLatencyTest();
                document.getElementById('pingValue').textContent = latencyResults.ping + ' ms';
                document.getElementById('jitterValue').textContent = latencyResults.jitter + ' ms';
                updateQualityIndicators(latencyResults);
                
                updateStage('stageDownload');
                statusMessage.textContent = 'Testing download speed...';
                progressBar.style.width = '50%';
                
                const downloadSpeed = await testDownloadSpeed();
                document.getElementById('downloadSpeed').textContent = downloadSpeed.toFixed(1) + ' Mbps';
                document.getElementById('speedValue').textContent = downloadSpeed.toFixed(1);
                progressBar.style.width = '75%';
                
                updateStage('stageUpload');
                statusMessage.textContent = 'Testing upload speed...';
                
                const uploadSpeed = await testUploadSpeed();
                document.getElementById('uploadSpeed').textContent = uploadSpeed.toFixed(1) + ' Mbps';
                progressBar.style.width = '90%';
                
                updateStage('stageComplete');
                statusMessage.textContent = 'Analyzing connection type...';
                progressBar.style.width = '100%';
                
                const connectionInfo = await detectConnectionType(
                    downloadSpeed,
                    uploadSpeed,
                    latencyResults.ping,
                    latencyResults.jitter
                );
                
                detectedConnectionType = connectionInfo.type;
                detectedNetworkTech = connectionInfo.technology;
                
                const badge = getConnectionBadge(connectionInfo.type, connectionInfo.technology);
                document.getElementById('connectionType').innerHTML = 
                    `<strong>Connection Type:</strong> ${connectionInfo.type} ${badge}`;
                
                document.getElementById('networkType').innerHTML = 
                    `<strong>Network Technology:</strong> ${connectionInfo.technology}`;
                
                if (connectionInfo.confidence > 70) {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> High (${connectionInfo.confidence}%)`;
                } else if (connectionInfo.confidence > 40) {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> Moderate (${connectionInfo.confidence}%)`;
                } else {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> Low - using best estimate`;
                }
                
                updateSpeedDisplay(downloadSpeed);
                
                setTimeout(() => {
                    resultDiv.style.display = 'block';
                    progressContainer.style.display = 'none';
                    serverTesting.style.display = 'none';
                    testButton.disabled = false;
                    testButton.textContent = 'Run New Test';
                    testInProgress = false;
                    statusMessage.textContent = 'Test complete!';
                }, 800);
                
            } catch (error) {
                statusMessage.textContent = 'Test failed. Please check your connection and try again.';
                console.error('Speed test error:', error);
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                testInProgress = false;
                progressContainer.style.display = 'none';
                serverTesting.style.display = 'none';
            }
        }
        
        // Initialize on load
        window.addEventListener('load', async () => {
            const preloader = document.getElementById('preloader');
            const testButton = document.getElementById('testButton');
            
            updateLoadingProgress(5);
            await new Promise(resolve => setTimeout(resolve, 300));
            
            updateLoadingProgress(15);
            await new Promise(resolve => setTimeout(resolve, 200));
            
            updateLoadingProgress(25);
            
            try {
                userLocation = await detectUserLocation();
                bestServer = await findBestServer(userLocation);
                
                // Update location display
                updateLocationDisplay(userLocation, bestServer);
                
                updateLoadingProgress(100);
                
            } catch (error) {
                console.log('Background initialization failed:', error);
                updateLoadingProgress(100);
            }
            
            setTimeout(() => {
                preloader.classList.add('hidden');
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
            }, 500);
        });
    </script>
</body>
</html>
