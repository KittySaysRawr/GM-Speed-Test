<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Speed Checker</title>
    <style>
        :root {
            --green-primary: #4CAF50;
            --green-dark: #2E7D32;
            --green-light: #C8E6C9;
            --amber: #FF9800;
            --red: #F44336;
            --text-dark: #333;
            --text-light: #fff;
            --bg-light: #f5f5f5;
            --bg-dark: #263238;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg-light);
            color: var(--text-dark);
            transition: all 0.3s ease;
            min-height: 100vh;
        }
        
        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-light);
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .dark-mode .container {
            background: #37474F;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
        }
        
        .server-info {
            background: var(--green-light);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-size: 0.9em;
        }
        
        .dark-mode .server-info {
            background: #1B5E20;
        }
        
        .speed-result {
            display: none;
            text-align: center;
            padding: 40px 30px;
            margin: 20px 0;
            border-radius: 8px;
            background: var(--green-light);
        }
        
        .dark-mode .speed-result {
            background: #1B5E20;
        }
        
        .speed-value {
            font-size: 3.5em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .speed-good { color: var(--green-dark); }
        .speed-medium { color: var(--amber); }
        .speed-slow { color: var(--red); }
        
        .test-button {
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            transition: all 0.3s ease;
            font-weight: bold;
            letter-spacing: 0.5px;
        }
        
        .test-button:hover:not(:disabled) {
            transform: translateY(-3px);
            background: var(--green-dark);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        .test-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--green-primary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }
        
        .test-details {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        .detail-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 10px;
            min-width: 150px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .dark-mode .detail-box {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .detail-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .detail-label {
            font-size: 0.95em;
            color: #666;
            font-weight: 500;
        }
        
        .dark-mode .detail-label {
            color: #ccc;
        }
        
        .progress-container {
            width: 100%;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            margin: 40px 0 30px 0;
            overflow: hidden;
            display: none;
        }
        
        .dark-mode .progress-container {
            background: #455A64;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--green-primary), var(--green-dark));
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .status-message {
            text-align: center;
            margin: 25px 0;
            font-size: 1.1em;
            color: #666;
            min-height: 28px;
            font-weight: 500;
        }
        
        .dark-mode .status-message {
            color: #ccc;
        }
        
        .test-stages {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            font-size: 0.95em;
            color: #666;
        }
        
        .test-stage {
            text-align: center;
            flex: 1;
            padding: 10px 5px;
            opacity: 0.5;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .test-stage.active {
            color: var(--green-primary);
            font-weight: bold;
            opacity: 1;
            border-bottom: 3px solid var(--green-primary);
        }
        
        .connection-info {
            text-align: center;
            margin-top: 30px;
            font-size: 0.9em;
            color: #666;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
        }
        
        .dark-mode .connection-info {
            background: rgba(0, 0, 0, 0.2);
            color: #ccc;
        }
        
        .server-testing {
            margin-top: 25px;
            padding: 15px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .dark-mode .server-testing {
            background: rgba(46, 125, 50, 0.2);
        }
        
        .jitter-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .accuracy-note {
            text-align: center;
            font-size: 0.85em;
            color: #888;
            margin-top: 20px;
            font-style: italic;
        }
        
        .dark-mode .accuracy-note {
            color: #aaa;
        }
        
        .server-map {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .server-pill {
            background: #e0e0e0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }
        
        .server-pill.testing {
            background: var(--green-primary);
            color: white;
            transform: scale(1.05);
        }
        
        .server-pill.selected {
            background: var(--green-dark);
            color: white;
            font-weight: bold;
        }
        
        .server-pill.failed {
            background: #ffebee;
            color: #c62828;
        }
        
        .dark-mode .server-pill {
            background: #455A64;
        }
        
        .dark-mode .server-pill.testing {
            background: var(--green-primary);
        }
        
        .dark-mode .server-pill.selected {
            background: var(--green-dark);
        }
        
        .connection-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .badge-wifi { background: #4CAF50; color: white; }
        .badge-4g { background: #2196F3; color: white; }
        .badge-5g { background: #9C27B0; color: white; }
        .badge-ethernet { background: #795548; color: white; }
        .badge-unknown { background: #9E9E9E; color: white; }
        
        /* Test indicators */
        .test-indicator {
            text-align: center;
            margin: 10px 0;
            font-size: 0.9em;
            color: #666;
        }
        
        .dark-mode .test-indicator {
            color: #ccc;
        }
        
        /* Simplified Preloader styles */
        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-light);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .dark-mode .preloader {
            background: var(--bg-dark);
        }
        
        .preloader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .preloader-content {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        .loading-text {
            font-size: 1.4em;
            color: var(--text-dark);
            font-weight: 500;
            margin-bottom: 10px;
        }
        
        .dark-mode .loading-text {
            color: var(--text-light);
        }
        
        .spinner-container {
            position: relative;
            width: 120px;
            height: 120px;
        }
        
        .spinner {
            width: 120px;
            height: 120px;
            border: 8px solid rgba(76, 175, 80, 0.2);
            border-top: 8px solid var(--green-primary);
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
        }
        
        .spinner-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            font-weight: bold;
            color: var(--green-dark);
        }
        
        .dark-mode .spinner-percentage {
            color: var(--green-light);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="preloader" id="preloader">
        <div class="preloader-content">
            <div class="loading-text">Please wait while the test loads...</div>
            <div class="spinner-container">
                <div class="spinner"></div>
                <div class="spinner-percentage" id="loadingPercentage">0%</div>
            </div>
        </div>
    </div>
    
    <button class="theme-toggle" onclick="toggleTheme()">Toggle Light/Dark</button>
    
    <div class="container">
        <div class="header">
            <h1>Internet Speed Checker</h1>
            <p>Testing your connection using the nearest available server</p>
        </div>
        
        <div class="server-info" id="serverInfo">
            Detecting your location and connection type...
        </div>
        
        <div class="server-map" id="serverMap" style="display: none;">
            <!-- Server pills will be added here dynamically -->
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="test-stages" id="testStages">
            <div class="test-stage" id="stageLocation">Finding Nearest Server</div>
            <div class="test-stage" id="stagePing">Latency Test</div>
            <div class="test-stage" id="stageDownload">Download Test</div>
            <div class="test-stage" id="stageUpload">Upload Test</div>
            <div class="test-stage" id="stageComplete">Analysis</div>
        </div>
        
        <div class="status-message" id="statusMessage">
            Ready to test your internet connection
        </div>
        
        <button class="test-button" onclick="startSpeedTest()" id="testButton">Start Speed Test</button>
        
        <div id="speedResult" class="speed-result">
            <h2>Connection Analysis Results</h2>
            <div id="speedValue" class="speed-value">--</div>
            <div id="speedStatus" style="font-size: 1.2em; margin-bottom: 30px;">--</div>
            
            <div class="test-details">
                <div class="detail-box">
                    <div class="detail-value" id="downloadSpeed">--</div>
                    <div class="detail-label">DOWNLOAD SPEED</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="downloadQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="uploadSpeed">--</div>
                    <div class="detail-label">UPLOAD SPEED</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="uploadQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="pingValue">--</div>
                    <div class="detail-label">PING</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="pingQuality">--</div>
                </div>
                <div class="detail-box">
                    <div class="detail-value" id="jitterValue">--</div>
                    <div class="detail-label">JITTER</div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;" id="jitterQuality">--</div>
                </div>
            </div>
            
            <div class="connection-info">
                <div id="ispInfo"><strong>ISP:</strong> --</div>
                <div id="connectionType" style="margin-top: 8px;"><strong>Connection Type:</strong> --</div>
                <div id="networkType" style="margin-top: 8px;"><strong>Network Technology:</strong> --</div>
                <div id="detectedLocation" style="margin-top: 8px;"><strong>Your Location:</strong> --</div>
                <div id="serverLocation" style="margin-top: 8px;"><strong>Test Server:</strong> --</div>
                <div id="connectionAccuracy" style="margin-top: 8px; font-size: 0.85em; color: #666;">
                    <strong>Detection Method:</strong> Speed-based analysis combined with browser API
                </div>
            </div>
            
            <div class="accuracy-note">
                Network type detected based on speed, latency, and browser capabilities
            </div>
        </div>
        
        <div class="server-testing" id="serverTesting" style="display: none;">
            <div id="serverStatus"><strong>Server Selection:</strong> Testing servers by proximity...</div>
            <div id="serverPing" style="margin-top: 5px;"></div>
        </div>
    </div>

    <script>
        // Theme toggle
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('theme', document.body.classList.contains('dark-mode') ? 'dark' : 'light');
        }
        
        // Load saved theme
        if (localStorage.getItem('theme') === 'dark') {
            document.body.classList.add('dark-mode');
        }
        
        // Location cache
        const LOCATION_CACHE_KEY = 'speedtest_location_cache';
        const LOCATION_CACHE_TTL = 30 * 60 * 1000;
        
        let testInProgress = false;
        let userLocation = null;
        let bestServer = null;
        let detectedConnectionType = 'Unknown';
        let detectedNetworkTech = 'Unknown';
        let loadingProgress = 0;
        
        // Improved Server database with better test endpoints
        const testServers = [
            { 
                id: 'cdn1', 
                name: "Global CDN", 
                pingUrl: "https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js",
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=10000000", // 10MB
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                city: "CDN Edge",
                lat: null,
                lon: null,
            },
            { 
                id: 'github', 
                name: "GitHub USA", 
                pingUrl: "https://raw.githubusercontent.com/git/git/master/README.md",
                downloadUrl: "https://raw.githubusercontent.com/torvalds/linux/master/README",
                uploadUrl: "https://httpbin.org/post",
                country: "US",
                city: "San Francisco",
                lat: 37.7749,
                lon: -122.4194,
            },
            { 
                id: 'cloudflare', 
                name: "Cloudflare Global", 
                pingUrl: "https://1.1.1.1/cdn-cgi/trace",
                downloadUrl: "https://speed.cloudflare.com/__down?bytes=5000000", // 5MB
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                city: "Anycast",
                lat: null,
                lon: null,
            },
            { 
                id: 'jsdelivr', 
                name: "jsDelivr CDN", 
                pingUrl: "https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js",
                downloadUrl: "https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js",
                uploadUrl: "https://httpbin.org/post",
                country: "Global",
                city: "CDN",
                lat: null,
                lon: null,
            }
        ];
        
        // Update loading progress
        function updateLoadingProgress(progress) {
            loadingProgress = Math.min(100, Math.max(0, progress));
            const percentageEl = document.getElementById('loadingPercentage');
            
            percentageEl.textContent = `${Math.round(loadingProgress)}%`;
            
            // Update spinner color based on progress
            const spinner = document.querySelector('.spinner');
            if (loadingProgress < 30) {
                spinner.style.borderTopColor = '#FF9800'; // Amber
            } else if (loadingProgress < 70) {
                spinner.style.borderTopColor = '#2196F3'; // Blue
            } else {
                spinner.style.borderTopColor = '#4CAF50'; // Green
            }
        }
        
        // Haversine formula for distance calculation
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Get cached location
        function getCachedLocation() {
            try {
                const cached = localStorage.getItem(LOCATION_CACHE_KEY);
                if (!cached) return null;
                
                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();
                
                if (now - timestamp < LOCATION_CACHE_TTL) {
                    return data;
                }
                
                localStorage.removeItem(LOCATION_CACHE_KEY);
                return null;
            } catch (error) {
                return null;
            }
        }
        
        // Cache location data
        function cacheLocationData(locationData) {
            try {
                const cacheData = {
                    data: locationData,
                    timestamp: Date.now()
                };
                localStorage.setItem(LOCATION_CACHE_KEY, JSON.stringify(cacheData));
            } catch (error) {
                // Ignore caching errors
            }
        }
        
        // Fast location detection
        async function detectUserLocation() {
            updateLoadingProgress(40);
            
            // Check cache first
            const cached = getCachedLocation();
            if (cached) {
                updateLoadingProgress(50);
                await new Promise(resolve => setTimeout(resolve, 300));
                return cached;
            }
            
            let locationData = {
                country: 'Unknown',
                city: 'Unknown',
                region: 'Unknown',
                latitude: null,
                longitude: null,
                isp: 'Unknown',
                method: 'unknown',
                countryCode: 'Unknown'
            };
            
            try {
                updateLoadingProgress(55);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);
                
                const response = await fetch('https://ipapi.co/json/', {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    updateLoadingProgress(65);
                    const data = await response.json();
                    locationData.country = data.country_name || 'Unknown';
                    locationData.countryCode = data.country_code || 'Unknown';
                    locationData.city = data.city || 'Unknown';
                    locationData.region = data.region || 'Unknown';
                    locationData.latitude = data.latitude;
                    locationData.longitude = data.longitude;
                    locationData.isp = data.org || data.asn || 'Unknown ISP';
                    locationData.method = 'ip_geolocation';
                    
                    updateLoadingProgress(70);
                    cacheLocationData(locationData);
                }
            } catch (error) {
                updateLoadingProgress(60);
                // Fallback detection
                const browserLanguage = navigator.language || 'en-US';
                const countryCode = browserLanguage.split('-')[1] || 'US';
                locationData.countryCode = countryCode;
                locationData.method = 'browser_language';
            }
            
            return locationData;
        }
        
        async function findBestServer(userLocation) {
            updateLoadingProgress(75);
            
            let candidates = [];
            
            if (userLocation.latitude && userLocation.longitude) {
                // Filter servers that have coordinates
                const serversWithCoords = testServers.filter(s => s.lat && s.lon);
                serversWithCoords.forEach(server => {
                    const distance = calculateDistance(
                        userLocation.latitude,
                        userLocation.longitude,
                        server.lat,
                        server.lon
                    );
                    
                    candidates.push({
                        server: server,
                        distance: distance
                    });
                });
                
                candidates.sort((a, b) => a.distance - b.distance);
            } else {
                // Use all servers
                candidates = testServers.map(server => ({ server, distance: null }));
            }
            
            // Test the closest servers
            let bestServer = null;
            let bestPing = Infinity;
            
            for (let i = 0; i < Math.min(3, candidates.length); i++) {
                const candidate = candidates[i];
                updateLoadingProgress(80 + (i * 5));
                
                try {
                    const ping = await testServerPing(candidate.server.pingUrl);
                    
                    if (ping < bestPing) {
                        bestPing = ping;
                        bestServer = candidate.server;
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                } catch (error) {
                    continue;
                }
            }
            
            updateLoadingProgress(95);
            
            return bestServer || candidates[0]?.server || testServers[0];
        }
        
        // IMPROVED: Better ping test with multiple attempts
        async function testServerPing(pingUrl) {
            let pings = [];
            
            for (let i = 0; i < 4; i++) {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    
                    await fetch(pingUrl, {
                        signal: controller.signal,
                        cache: 'no-cache',
                        mode: 'no-cors',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const ping = endTime - startTime;
                    
                    // Only accept reasonable pings
                    if (ping > 1 && ping < 2000) {
                        pings.push(ping);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                } catch (error) {
                    pings.push(100); // Default fallback
                }
            }
            
            if (pings.length === 0) return 100;
            
            // Return median ping for stability
            pings.sort((a, b) => a - b);
            return pings[Math.floor(pings.length / 2)];
        }
        
        // IMPROVED: Much better download speed test
        async function testDownloadSpeed() {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Testing download speed...';
            
            let speeds = [];
            const testDuration = 4000; // Test for 4 seconds
            const parallelConnections = 4; // Use 4 parallel connections
            
            // Try multiple servers for better accuracy
            const downloadServers = [
                { url: "https://speed.cloudflare.com/__down?bytes=10000000", size: 10000000 }, // 10MB
                { url: "https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js", size: 89513 }, // jQuery
                { url: "https://raw.githubusercontent.com/torvalds/linux/master/README", size: 37000 }, // Linux README
                { url: "https://httpbin.org/bytes/1000000", size: 1000000 } // 1MB from httpbin
            ];
            
            for (const server of downloadServers) {
                try {
                    statusMessage.textContent = `Testing download from ${server.url.includes('cloudflare') ? 'Cloudflare' : server.url.includes('github') ? 'GitHub' : 'CDN'}...`;
                    
                    const speed = await measureDownloadSpeed(server.url, server.size, testDuration, parallelConnections);
                    
                    if (speed > 0.1 && speed < 5000) { // Reasonable bounds
                        speeds.push(speed);
                    }
                    
                    if (speeds.length >= 2) break; // Get results from 2 servers
                    
                } catch (error) {
                    continue;
                }
            }
            
            if (speeds.length === 0) {
                // Fallback to single connection test
                return await simpleDownloadTest();
            }
            
            // Return average of valid speeds
            const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            return Math.round(averageSpeed * 10) / 10; // Round to 1 decimal
        }
        
        async function measureDownloadSpeed(url, fileSize, duration, connections) {
            const startTime = performance.now();
            let totalBytes = 0;
            let activeConnections = 0;
            
            return new Promise((resolve, reject) => {
                const connectionPromises = [];
                
                for (let i = 0; i < connections; i++) {
                    connectionPromises.push(
                        fetch(url + `?nocache=${Date.now()}-${i}`, {
                            cache: 'no-store',
                            mode: 'cors',
                            headers: {
                                'Cache-Control': 'no-cache',
                                'Pragma': 'no-cache'
                            }
                        }).then(async response => {
                            const reader = response.body.getReader();
                            let bytesReceived = 0;
                            
                            while (performance.now() - startTime < duration) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                bytesReceived += value.length;
                                totalBytes += value.length;
                            }
                            
                            reader.cancel();
                            return bytesReceived;
                        }).catch(error => {
                            return 0;
                        })
                    );
                }
                
                // Monitor progress
                const progressInterval = setInterval(() => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed >= duration) {
                        clearInterval(progressInterval);
                        
                        // Calculate speed
                        const speedMbps = (totalBytes * 8) / (duration / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                    }
                }, 100);
                
                // Timeout after duration + buffer
                setTimeout(() => {
                    clearInterval(progressInterval);
                    const elapsed = performance.now() - startTime;
                    const speedMbps = (totalBytes * 8) / (elapsed / 1000) / (1024 * 1024);
                    resolve(speedMbps);
                }, duration + 1000);
            });
        }
        
        async function simpleDownloadTest() {
            try {
                const startTime = performance.now();
                const response = await fetch('https://speed.cloudflare.com/__down?bytes=5000000' + `?t=${Date.now()}`, {
                    cache: 'no-store',
                    mode: 'cors'
                });
                const blob = await response.blob();
                const endTime = performance.now();
                
                const duration = (endTime - startTime) / 1000;
                const speedMbps = (blob.size * 8) / (1024 * 1024) / duration;
                
                return Math.max(0.1, speedMbps);
            } catch (error) {
                return 10; // Default fallback
            }
        }
        
        // IMPROVED: Much better upload speed test
        async function testUploadSpeed() {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Testing upload speed...';
            
            let speeds = [];
            const testDuration = 4000; // Test for 4 seconds
            
            // Create larger test data (1MB for upload)
            const testData = generateTestData(1024 * 1024); // 1MB
            
            // Try multiple upload endpoints
            const uploadEndpoints = [
                'https://httpbin.org/post',
                'https://ptsv2.com/t/test/post',
                'https://echo.zuplo.io/'
            ];
            
            for (const endpoint of uploadEndpoints) {
                try {
                    const speed = await measureUploadSpeed(endpoint, testData, testDuration);
                    
                    if (speed > 0.1 && speed < 1000) { // Reasonable bounds
                        speeds.push(speed);
                    }
                    
                    if (speeds.length >= 2) break; // Get results from 2 endpoints
                    
                } catch (error) {
                    continue;
                }
            }
            
            if (speeds.length === 0) {
                // Fallback test
                return await simpleUploadTest();
            }
            
            // Return average of valid speeds
            const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
            return Math.round(averageSpeed * 10) / 10; // Round to 1 decimal
        }
        
        function generateTestData(size) {
            // Generate random test data
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < size; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }
        
        async function measureUploadSpeed(endpoint, testData, duration) {
            const startTime = performance.now();
            let totalBytesSent = 0;
            
            return new Promise((resolve, reject) => {
                const sendChunk = async () => {
                    if (performance.now() - startTime >= duration) {
                        const elapsed = performance.now() - startTime;
                        const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                        return;
                    }
                    
                    try {
                        const chunkSize = Math.min(50000, testData.length); // 50KB chunks
                        const chunk = testData.substring(0, chunkSize);
                        
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 5000);
                        
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'text/plain',
                                'Content-Length': chunk.length.toString()
                            },
                            body: chunk,
                            mode: 'cors',
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (response.ok) {
                            totalBytesSent += chunk.length;
                            // Continue sending
                            setTimeout(sendChunk, 0);
                        } else {
                            const elapsed = performance.now() - startTime;
                            const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                            resolve(speedMbps);
                        }
                    } catch (error) {
                        const elapsed = performance.now() - startTime;
                        const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                        resolve(speedMbps);
                    }
                };
                
                // Start the upload
                sendChunk();
                
                // Timeout
                setTimeout(() => {
                    const elapsed = performance.now() - startTime;
                    const speedMbps = (totalBytesSent * 8) / (elapsed / 1000) / (1024 * 1024);
                    resolve(speedMbps);
                }, duration + 1000);
            });
        }
        
        async function simpleUploadTest() {
            try {
                const testData = generateTestData(500 * 1024); // 500KB
                
                const startTime = performance.now();
                const response = await fetch('https://httpbin.org/post', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain',
                    },
                    body: testData,
                    mode: 'cors'
                });
                
                await response.json();
                const endTime = performance.now();
                
                const duration = (endTime - startTime) / 1000;
                const speedMbps = (testData.length * 8) / (1024 * 1024) / duration;
                
                return Math.max(0.1, speedMbps);
                
            } catch (error) {
                return 2; // Default fallback
            }
        }
        
        // IMPROVED: Better latency test
        async function performLatencyTest() {
            let pings = [];
            let jitterSamples = [];
            
            statusMessage.textContent = 'Measuring latency and jitter...';
            
            // Test with multiple sizes to get accurate latency
            for (let i = 0; i < 8; i++) {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 2000);
                    
                    // Use a small request for latency testing
                    await fetch(bestServer.pingUrl + `?size=100&t=${Date.now()}-${i}`, {
                        signal: controller.signal,
                        cache: 'no-store',
                        mode: 'cors',
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const ping = endTime - startTime;
                    
                    // Only accept reasonable pings
                    if (ping > 1 && ping < 2000) {
                        pings.push(ping);
                        
                        // Calculate jitter between consecutive pings
                        if (pings.length > 1) {
                            const jitter = Math.abs(pings[pings.length - 1] - pings[pings.length - 2]);
                            jitterSamples.push(jitter);
                        }
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                } catch (error) {
                    pings.push(50); // Default fallback
                }
            }
            
            if (pings.length === 0) {
                return { ping: 50, jitter: 5 };
            }
            
            // Calculate median ping for stability
            pings.sort((a, b) => a - b);
            const medianPing = pings[Math.floor(pings.length / 2)];
            
            // Calculate average jitter
            let jitter = 1;
            if (jitterSamples.length > 0) {
                jitter = jitterSamples.reduce((a, b) => a + b, 0) / jitterSamples.length;
            }
            
            return {
                ping: Math.round(medianPing),
                jitter: Math.round(jitter * 10) / 10
            };
        }
        
        // Rest of the functions remain the same...
        async function detectConnectionType(downloadSpeed, uploadSpeed, ping, jitter) {
            let connectionInfo = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            const browserDetection = detectConnectionFromBrowser();
            if (browserDetection.type !== 'Unknown') {
                connectionInfo = browserDetection;
                connectionInfo.details.push('Detected via browser API');
                connectionInfo.confidence = 70;
            }
            
            const speedDetection = detectConnectionFromSpeed(downloadSpeed, uploadSpeed, ping, jitter);
            
            if (speedDetection.confidence > connectionInfo.confidence || connectionInfo.type === 'Unknown') {
                connectionInfo = speedDetection;
                connectionInfo.details.push('Detected via speed analysis');
            }
            
            if (connectionInfo.type === 'Mobile' || connectionInfo.type === '4G' || connectionInfo.type === '5G') {
                if (downloadSpeed > 100 && ping < 30 && jitter < 15) {
                    if (connectionInfo.technology !== '5G') {
                        connectionInfo.technology = '5G';
                        connectionInfo.details.push('Upgraded to 5G based on speed/latency profile');
                        connectionInfo.confidence = Math.min(90, connectionInfo.confidence + 20);
                    }
                } else if (downloadSpeed > 200 && ping < 20) {
                    connectionInfo.technology = '5G';
                    connectionInfo.type = '5G';
                    connectionInfo.confidence = 95;
                    connectionInfo.details.push('Identified as 5G based on ultra-high speed');
                }
            }
            
            return connectionInfo;
        }
        
        function detectConnectionFromBrowser() {
            const info = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            if (!('connection' in navigator)) {
                info.details.push('No browser connection API available');
                return info;
            }
            
            const conn = navigator.connection;
            
            if (conn.type) {
                info.type = conn.type;
                info.confidence = 60;
                info.details.push(`Browser reports type: ${conn.type}`);
            }
            
            if (conn.effectiveType) {
                info.technology = conn.effectiveType.toUpperCase();
                info.confidence = Math.max(info.confidence, 50);
                info.details.push(`Browser reports effective type: ${conn.effectiveType}`);
                
                if (conn.effectiveType.includes('4g')) {
                    info.technology = '4G/LTE';
                } else if (conn.effectiveType.includes('3g')) {
                    info.technology = '3G';
                } else if (conn.effectiveType.includes('2g')) {
                    info.technology = '2G';
                }
            }
            
            if (conn.downlink) {
                info.details.push(`Estimated downlink: ${conn.downlink} Mbps`);
            }
            
            if (conn.type === 'cellular' || conn.effectiveType) {
                info.type = 'Mobile';
                
                if (conn.effectiveType && conn.effectiveType === '4g') {
                    info.details.push('Browser reports 4G (may be 5G mislabeled)');
                }
            }
            
            if (conn.type === 'wifi' || conn.type === 'wimax') {
                info.type = 'WiFi';
                info.technology = 'WiFi';
            }
            
            if (conn.type === 'ethernet') {
                info.type = 'Wired';
                info.technology = 'Ethernet';
            }
            
            return info;
        }
        
        function detectConnectionFromSpeed(downloadSpeed, uploadSpeed, ping, jitter) {
            const info = {
                type: 'Unknown',
                technology: 'Unknown',
                confidence: 0,
                details: []
            };
            
            let bestMatch = null;
            let bestScore = 0;
            
            const networkTypePatterns = {
                '5G': {
                    minDownload: 100,
                    maxDownload: 2000,
                    minUpload: 10,
                    maxUpload: 100,
                    maxPing: 50,
                    maxJitter: 20,
                    typicalLatency: 10,
                    characteristics: ['Very high download speed', 'Low latency', 'Mobile connection']
                },
                '4G/LTE': {
                    minDownload: 10,
                    maxDownload: 100,
                    minUpload: 2,
                    maxUpload: 50,
                    maxPing: 100,
                    maxJitter: 30,
                    typicalLatency: 30,
                    characteristics: ['Good mobile speed', 'Moderate latency']
                },
                'Fiber': {
                    minDownload: 50,
                    maxDownload: 1000,
                    minUpload: 50,
                    maxUpload: 1000,
                    maxPing: 30,
                    maxJitter: 10,
                    typicalLatency: 5,
                    characteristics: ['High symmetrical speeds', 'Very low latency', 'Stable connection']
                },
                'Cable': {
                    minDownload: 25,
                    maxDownload: 500,
                    minUpload: 5,
                    maxUpload: 50,
                    maxPing: 40,
                    maxJitter: 15,
                    typicalLatency: 15,
                    characteristics: ['Good download, slower upload', 'Home broadband']
                },
                'DSL': {
                    minDownload: 5,
                    maxDownload: 100,
                    minUpload: 1,
                    maxUpload: 20,
                    maxPing: 60,
                    maxJitter: 25,
                    typicalLatency: 25,
                    characteristics: ['Slower speeds', 'Higher latency', 'Traditional broadband']
                },
                'WiFi': {
                    minDownload: 10,
                    maxDownload: 300,
                    minUpload: 5,
                    maxUpload: 100,
                    maxPing: 50,
                    maxJitter: 30,
                    typicalLatency: 20,
                    characteristics: ['Variable speeds', 'Wireless connection']
                },
                'Satellite': {
                    minDownload: 5,
                    maxDownload: 100,
                    minUpload: 1,
                    maxUpload: 20,
                    minPing: 500,
                    maxPing: 2000,
                    maxJitter: 100,
                    characteristics: ['High latency', 'Weather affected']
                }
            };
            
            for (const [tech, pattern] of Object.entries(networkTypePatterns)) {
                let score = 0;
                let matches = [];
                
                if (downloadSpeed >= pattern.minDownload && downloadSpeed <= pattern.maxDownload) {
                    score += 25;
                    matches.push(`Download speed matches ${tech} range`);
                } else if (downloadSpeed > pattern.maxDownload) {
                    score += 15;
                    matches.push(`Download speed higher than typical ${tech}`);
                }
                
                if (uploadSpeed >= pattern.minUpload && uploadSpeed <= pattern.maxUpload) {
                    score += 20;
                    matches.push(`Upload speed matches ${tech} range`);
                }
                
                if (ping <= pattern.maxPing) {
                    score += 30;
                    matches.push(`Latency matches ${tech}`);
                }
                
                if (jitter <= pattern.maxJitter) {
                    score += 15;
                    matches.push(`Jitter matches ${tech}`);
                }
                
                if (tech === 'Fiber') {
                    const ratio = uploadSpeed / downloadSpeed;
                    if (ratio > 0.3 && ratio < 3) {
                        score += 20;
                        matches.push('Symmetrical speeds suggest fiber');
                    }
                }
                
                if (tech === 'Satellite' && ping > 500) {
                    score += 40;
                    matches.push('Very high latency suggests satellite');
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = {
                        tech: tech,
                        score: score,
                        matches: matches
                    };
                }
            }
            
            if (bestMatch && bestMatch.score > 30) {
                info.technology = bestMatch.tech;
                info.confidence = Math.min(90, bestMatch.score);
                info.details = bestMatch.matches;
                
                if (bestMatch.tech === '5G' || bestMatch.tech === '4G/LTE') {
                    info.type = 'Mobile';
                } else if (bestMatch.tech === 'WiFi') {
                    info.type = 'WiFi';
                } else if (bestMatch.tech === 'Fiber' || bestMatch.tech === 'Cable' || bestMatch.tech === 'DSL') {
                    info.type = 'Wired';
                } else if (bestMatch.tech === 'Satellite') {
                    info.type = 'Satellite';
                }
            }
            
            return info;
        }
        
        function getConnectionBadge(type, tech) {
            let badgeClass = 'badge-unknown';
            let badgeText = tech || type;
            
            if (tech === '5G') {
                badgeClass = 'badge-5g';
                badgeText = '5G';
            } else if (tech === '4G/LTE' || tech === '4G') {
                badgeClass = 'badge-4g';
                badgeText = '4G/LTE';
            } else if (type === 'WiFi' || tech === 'WiFi') {
                badgeClass = 'badge-wifi';
                badgeText = 'WiFi';
            } else if (tech === 'Ethernet' || type === 'Wired') {
                badgeClass = 'badge-ethernet';
                badgeText = 'Ethernet';
            } else if (tech === '3G') {
                badgeClass = 'badge-4g';
                badgeText = '3G';
            }
            
            return `<span class="connection-badge ${badgeClass}">${badgeText}</span>`;
        }
        
        // Main speed test function
        async function startSpeedTest() {
            if (testInProgress) return;
            
            const resultDiv = document.getElementById('speedResult');
            const testButton = document.getElementById('testButton');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const statusMessage = document.getElementById('statusMessage');
            const serverTesting = document.getElementById('serverTesting');
            
            testInProgress = true;
            testButton.disabled = true;
            testButton.textContent = 'Testing in Progress...';
            resultDiv.style.display = 'none';
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            serverTesting.style.display = 'block';
            
            document.querySelectorAll('.test-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            
            try {
                updateStage('stageLocation');
                statusMessage.textContent = 'Detecting your location and finding nearest server...';
                progressBar.style.width = '10%';
                
                if (!userLocation) {
                    userLocation = await detectUserLocation();
                }
                
                if (!bestServer) {
                    bestServer = await findBestServer(userLocation);
                }
                
                let locationText = '';
                if (userLocation.city !== 'Unknown') locationText += userLocation.city;
                if (userLocation.country !== 'Unknown') {
                    if (locationText) locationText += ', ';
                    locationText += userLocation.country;
                }
                
                document.getElementById('detectedLocation').innerHTML = 
                    `<strong>Your Location:</strong> ${locationText || 'Detected from connection data'}`;
                
                document.getElementById('serverInfo').textContent = 
                    `Testing against nearest server: ${bestServer.name}`;
                document.getElementById('serverLocation').innerHTML = 
                    `<strong>Test Server:</strong> ${bestServer.name} (${bestServer.country})`;
                
                if (userLocation.isp !== 'Unknown' && userLocation.isp !== 'Unknown ISP') {
                    document.getElementById('ispInfo').innerHTML = `<strong>ISP:</strong> ${userLocation.isp}`;
                }
                
                updateStage('stagePing');
                statusMessage.textContent = 'Measuring connection quality...';
                progressBar.style.width = '25%';
                
                const latencyResults = await performLatencyTest();
                document.getElementById('pingValue').textContent = latencyResults.ping + ' ms';
                document.getElementById('jitterValue').textContent = latencyResults.jitter + ' ms';
                updateQualityIndicators(latencyResults);
                
                updateStage('stageDownload');
                statusMessage.textContent = 'Testing download speed...';
                progressBar.style.width = '50%';
                
                const downloadSpeed = await testDownloadSpeed();
                document.getElementById('downloadSpeed').textContent = downloadSpeed.toFixed(1) + ' Mbps';
                document.getElementById('speedValue').textContent = downloadSpeed.toFixed(1);
                progressBar.style.width = '75%';
                
                updateStage('stageUpload');
                statusMessage.textContent = 'Testing upload speed...';
                
                const uploadSpeed = await testUploadSpeed();
                document.getElementById('uploadSpeed').textContent = uploadSpeed.toFixed(1) + ' Mbps';
                progressBar.style.width = '90%';
                
                updateStage('stageComplete');
                statusMessage.textContent = 'Analyzing connection type...';
                progressBar.style.width = '100%';
                
                const connectionInfo = await detectConnectionType(
                    downloadSpeed,
                    uploadSpeed,
                    latencyResults.ping,
                    latencyResults.jitter
                );
                
                detectedConnectionType = connectionInfo.type;
                detectedNetworkTech = connectionInfo.technology;
                
                const badge = getConnectionBadge(connectionInfo.type, connectionInfo.technology);
                document.getElementById('connectionType').innerHTML = 
                    `<strong>Connection Type:</strong> ${connectionInfo.type} ${badge}`;
                
                document.getElementById('networkType').innerHTML = 
                    `<strong>Network Technology:</strong> ${connectionInfo.technology}`;
                
                if (connectionInfo.confidence > 70) {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> High (${connectionInfo.confidence}%)`;
                } else if (connectionInfo.confidence > 40) {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> Moderate (${connectionInfo.confidence}%)`;
                } else {
                    document.getElementById('connectionAccuracy').innerHTML = 
                        `<strong>Detection Confidence:</strong> Low - using best estimate`;
                }
                
                updateSpeedDisplay(downloadSpeed);
                
                setTimeout(() => {
                    resultDiv.style.display = 'block';
                    progressContainer.style.display = 'none';
                    serverTesting.style.display = 'none';
                    testButton.disabled = false;
                    testButton.textContent = 'Run New Test';
                    testInProgress = false;
                    statusMessage.textContent = 'Test complete! Run again to verify results.';
                }, 800);
                
            } catch (error) {
                statusMessage.textContent = 'Test failed. Please check your connection and try again.';
                console.error('Speed test error:', error);
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
                testInProgress = false;
                progressContainer.style.display = 'none';
                serverTesting.style.display = 'none';
            }
        }
        
        function updateStage(stageId) {
            document.querySelectorAll('.test-stage').forEach(stage => {
                stage.classList.remove('active');
            });
            document.getElementById(stageId).classList.add('active');
        }
        
        function updateSpeedDisplay(speed) {
            const speedValue = document.getElementById('speedValue');
            const speedStatus = document.getElementById('speedStatus');
            
            speedValue.className = 'speed-value ';
            
            if (speed > 100) {
                speedValue.classList.add('speed-good');
                speedStatus.textContent = 'Excellent Connection';
                speedStatus.style.color = '#2E7D32';
            } else if (speed > 50) {
                speedValue.classList.add('speed-good');
                speedStatus.textContent = 'Very Good Connection';
                speedStatus.style.color = '#2E7D32';
            } else if (speed > 25) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Good Connection';
                speedStatus.style.color = '#FF9800';
            } else if (speed > 10) {
                speedValue.classList.add('speed-medium');
                speedStatus.textContent = 'Fair Connection';
                speedStatus.style.color = '#FF9800';
            } else if (speed > 3) {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Slow Connection';
                speedStatus.style.color = '#F44336';
            } else {
                speedValue.classList.add('speed-slow');
                speedStatus.textContent = 'Very Slow Connection';
                speedStatus.style.color = '#F44336';
            }
            
            speedValue.innerHTML = `${speed.toFixed(1)} <span style="font-size: 0.5em;">Mbps</span>`;
        }
        
        function updateQualityIndicators(results) {
            const pingQuality = document.getElementById('pingQuality');
            if (results.ping < 30) {
                pingQuality.textContent = 'Excellent';
                pingQuality.style.color = '#2E7D32';
            } else if (results.ping < 60) {
                pingQuality.textContent = 'Good';
                pingQuality.style.color = '#FF9800';
            } else if (results.ping < 100) {
                pingQuality.textContent = 'Fair';
                pingQuality.style.color = '#FF9800';
            } else {
                pingQuality.textContent = 'Poor';
                pingQuality.style.color = '#F44336';
            }
            
            const jitterQuality = document.getElementById('jitterQuality');
            if (results.jitter < 5) {
                jitterQuality.textContent = 'Excellent';
                jitterQuality.style.color = '#2E7D32';
            } else if (results.jitter < 10) {
                jitterQuality.textContent = 'Good';
                jitterQuality.style.color = '#FF9800';
            } else if (results.jitter < 20) {
                jitterQuality.textContent = 'Fair';
                jitterQuality.style.color = '#FF9800';
            } else {
                jitterQuality.textContent = 'Poor';
                jitterQuality.style.color = '#F44336';
            }
        }
        
        // Initialize on load
        window.addEventListener('load', async () => {
            const preloader = document.getElementById('preloader');
            const testButton = document.getElementById('testButton');
            
            // Initial loading progress
            updateLoadingProgress(5);
            await new Promise(resolve => setTimeout(resolve, 300));
            
            updateLoadingProgress(15);
            await new Promise(resolve => setTimeout(resolve, 200));
            
            updateLoadingProgress(25);
            
            // Background initialization
            try {
                userLocation = await detectUserLocation();
                bestServer = await findBestServer(userLocation);
                
                let locationText = '';
                if (userLocation.city !== 'Unknown') locationText += userLocation.city;
                if (userLocation.country !== 'Unknown') {
                    if (locationText) locationText += ', ';
                    locationText += userLocation.country;
                }
                
                if (locationText) {
                    document.getElementById('serverInfo').innerHTML = 
                        `Ready to test from <strong>${locationText}</strong> using nearest server`;
                }
                
                // Show initial connection info if available
                if ('connection' in navigator) {
                    const conn = navigator.connection;
                    let info = '';
                    
                    if (conn.effectiveType) {
                        info = `Browser reports: ${conn.effectiveType.toUpperCase()}`;
                    }
                    if (conn.downlink) {
                        info += info ? ` (${conn.downlink} Mbps)` : `Estimated: ${conn.downlink} Mbps`;
                    }
                    
                    if (info) {
                        document.getElementById('statusMessage').textContent = info;
                    }
                }
                
                updateLoadingProgress(100);
                
            } catch (error) {
                console.log('Background initialization failed:', error);
                updateLoadingProgress(100);
            }
            
            // Hide preloader after completion
            setTimeout(() => {
                preloader.classList.add('hidden');
                testButton.disabled = false;
                testButton.textContent = 'Start Speed Test';
            }, 500);
        });
    </script>
</body>
</html>
